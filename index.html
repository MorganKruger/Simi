<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    html {
      background-color: linen;
      touch-action: none;
      user-select: none;
      overflow: hidden;
    }

    body {
      justify-items: center;
      justify-content: center;
      display: grid;
      overflow: hidden;
    }
    
    canvas {
      top: 0;
      background-color: #ffffff;
    }

    #tooltip {
      z-index: 1;
      opacity: 0;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 2rem;
      background-color: #00000082;
      color: white;
      text-align: center;
      transition-duration: 105ms;
      font-family: Arial, Helvetica, sans-serif;
      font-weight: 600;
      text-shadow: 0 0 8px black;
      pointer-events: none;
    }
    
    #touch-arrow-controller {
      display: none;
      position: absolute;
      grid-template: repeat(3, 1fr) / repeat(3, 1fr);
      user-select: none;
      pointer-events: none;
      z-index: 2;
      line-height: 0;

      & > * {
        background-color: #00000029;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 3em;
        pointer-events: initial;

        &:active {
          background-color: transparent;
        }
      }

      & #up {
        grid-area: 1 / 2;
      }

      & #left {
        grid-area: 2 / 1;
      }

      & #adjust-controller {
        grid-area: 2 / 2;
      }

      & #right {
        grid-area: 2 / 3;
      }

      & #down {
        grid-area: 3 / 2;
      }
    }

    #joystick-area {
      position: absolute;
      z-index: 2;
      height: 100%;
      width: 40%;
      
      & #joystick-socket {
        display: none;
        position: absolute;
        width: 80px;
        height: 80px;
        border: 1px solid #00000029;
        border-radius: 50%;
        align-items: center;
        justify-items: center;
        transform: translate(-50%, -50%);
  
        & #joystick-thumb {
          background-color: #00000029;
          width: 90%;
          height: 90%;
          border-radius: 50%;
        }
      }
    }

  </style>
</head>

<body>
  <div id="main">
    <div id="touch-arrow-controller">
      <div id="up">&blacktriangle;</div>
      <div id="left">&blacktriangleleft;</div>
      <div id="adjust-controller">&there4;</div>
      <div id="right">&blacktriangleright;</div>
      <div id="down">&blacktriangledown;</div>
    </div>
    <div id="joystick-area">
      <div id="joystick-socket">
        <div id="joystick-thumb"></div>
      </div>
    </div>
    <div id="tooltip"></div>
    <canvas id="canvas" width="1600" height="900"></canvas>
  </div>

  <script defer>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const FPS = 60;
    const controller = {
      up: false,
      left: false,
      right: false,
      down: false,
      interact: false,
      joystick: null,
    }
    const version = "v0.4.3";
    let userHasTouchScreen = navigator.maxTouchPoints > 0 && window.matchMedia("(pointer: coarse)").matches;

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }
    class Vector {
      constructor(mag, dir) {
        this.magnitude = mag;
        this.direction = dir;
      }

      static fromPoints(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const magnitude = Math.sqrt(dx * dx + dy * dy);
        const direction = Math.atan2(dy, dx);
        return new Vector(magnitude, direction);
      }

      toPoint() {
        return new Point(
          this.magnitude * Math.cos(this.direction),
          this.magnitude * Math.sin(this.direction)
        );
      }
    }

    const playerStart = new Point(canvas.width / 2, canvas.height / 2);
    const player = {
      x: playerStart.x,
      y: playerStart.y,
      size: 10,
      movement: Vector.fromPoints(playerStart, playerStart),
      targetSpeed: null,
      maxSpeed: 8,
      acceleration: 1.3,
      friction: 1,
      color: "rgb(255, 0, 0, 1)",
    }

    class Area {
      constructor(doorsArray, particlesArray, targetsArray, itemsArray, backgroundColor, areaIsUnlocked) {
        this.doors = doorsArray;
        this.particles = particlesArray;
        this.targets = targetsArray;
        this.items = itemsArray;
        this.color = backgroundColor;
        this.unlocked = areaIsUnlocked;
      }
    }
    class Door {
      constructor(whichSide, destination, doorPosition) {
        this.side = whichSide;
        this.destination = destination;
        this.position = doorPosition;
      }
    }

    let scene = "main";
    let gameSpeed = .6;

    // settings
    let doorSize = 70;
    let showDoorLabel = true;
    let showDoorway = true;
    let showVersionCode = true;
    let showCurrency = true;
    let showNormalTargets = true;
    let showSpecialTargets = true;
    let showCosmeticParticles = 2;
    let showDrops = 2;
    let strictTargetAmountLimit = false;
    let useTouchController = true;
    let useTouchJoystick = true;
    let touchControllerSize = ()=>{return Math.min(window.innerWidth, window.innerHeight) / 2};

    let joystickStart = null;
    const doorColor = "#00000043";

    let shopFocus;
    let interactionMessage = userHasTouchScreen ? "tap" : "E";
    const itemButtonSize = 50;
    const minimumLabelWidth = 200;

    let points = 0;
    let pointsMult = 1; // base multiplier appllied when gaining points
    let leaves = 0;
    let particleBase = 1; // points from targets
    const particleSize = 8; // visible size of most particles

    let normalParticleTime = 1; // amount of time before a basic particle disappears
    let breadthSizeBonus = 10; // increase target breadth effectiveness on average
    let minimumTargetSize = 30;
    let breadthBonus = 5; // points from target breadth
    let potencyBonus = 10; // points from target potency
    let minimumPotency = 0; // minimum potency (1=100%)
    let maxNormalPotency = .3; // maximum potency (1=100%)
    let superPotentChance = .05; // chance for 100% potency (1=100%)
    let superPotentValue = 3 // amount of bonus particles for super potency

    let maxTargets = 10; // (prevents lag and balances gameplay)
    let safeMaxTargets = 200; // (prevents lag and balances gameplay)
    let targetChance = .0025; // chance for a new target to appear each frame (1=100%)
    let maxSpecialTargets = 1; // (balances gameplay)
    let specialTargetCount = 0; // amount of special targets currently in play
    let specialTargetRateMult = 1; // increases the rate of all special target appearances
    //
    let darkTargetUnlocked = false; // dark target can spawn
    let darkTargetChance = .0002; // chance for a new dark target to appear each frame (1=100%)
    let darkTargetConfettiMult = 1; // amount of particles from dark targets
    //
    let explosiveTargetUnlocked = false; // explosive target can spawn
    let explosiveTargetChance = .0002; // chance for a new dark target to appear each frame (1=100%)
    let explosiveLifetimeMult = 1; // increase the amount of time that the explosive particles last for
    let minExplosiveConfetti = 30; // minimum amount of particles that spawn from an explosive target
    let explosiveConfettiMult = 1; // increase the amount of particles that spawn from an explosive target
    //
    let goldTargetUnlocked = false; // gold target can spawn
    let goldTargetChance = .0002; // chance for a new gold target to appear each frame (1=100%)
    let goldTargetDecay = 1; // size reduction per frame of the gold target
    let goldTargetSize = 45; // size reduction per frame of the gold target
    const goldTargetMinSize = 25; // minimum size before a gold target disappears
    let goldTargetDrop = 1; // gold target shoots 2 particles per frame instead of 1
    let goldAutoCollect = false; // gold targets auto collect after being collected once

    const maxGardenPlots = 15; // the maximum allowed number of garden plots to be displayed in the garden area
    let cropGrowthChance = .0003; // chance for garden crops to increase in their 'growth' value by some amount
    const maxCropSize = 28; // maximum physical size for crop display and collision
    let cropHarvestBonus = 0; // multiplies the amount of leaves harvested from garden crops
    let gardenStripCount = 0; // sum count of garden strips across all plots
    let rabbitSpeed = 15; // max rabbit speed
    let minWetness = 7000; // minimum amount of frames before garden plot has wetness set to "false"
    let wetRandRange = 4000; // the max amount of frames after the minWetness for which a garden plot may remain wet
    let fertilizerAmount = 200; // number of crop harvests before a plot goes infertile again
    const maxGardenSpecialTargets = 1;
    //
    let rainUnlocked = false; // whether or not rain targets are allowed to spawn
    let rainTargetChance = .00005; // .00005 = 1/20000 frames / 3600 frames = ~5.5 minutes
    let rainDuration = 0; // duration of the rain event
    let showRain = true; // whether or not rain renders
    let rainSpeed = 35; // visible speed of the rain particles
    let rainAngle = 0; // x velocity for the rain particles
    let rainAmount = 3;  // amount of rain particles to be spawned each frame during rain
    let rainIntensity = 1; // limiting value that multiplies against other rain values

    let turtleSpeed = 6;

    const unlockItems = (itemList, ...itemIDs) => {
      for (let i = 0; i < itemIDs.length; i++) {
        const item = itemList.find(item => item.id == itemIDs[i]);
        item.unlocked = true;
      }
      updateShopPositions(itemList)
    }
    const lockItems = (itemList, ...itemIDs) => {
      for (let i = 0; i < itemIDs.length; i++) {
        const item = itemList.find(item => item.id == itemIDs[i]);
        item.unlocked = false;
        item.x = null;
        item.y = null;
      }
    }

    let shopItems = [
      //#region basic upgrades
      {
        id: "drop per target",
        title: "+1 Drop Per Target",
        unlocked: true,
        level: 0,
        maxLevel: 9,
        price: 20,
        x: undefined,
        y: undefined,
        tooltip: "Increase the base amount of drops when collecting a normal target",
        onPurchase: function () {
          this.price += 30 * this.level;
          particleBase += 1;

          this.tooltip = "Increase the base amount of drops when collecting a normal target";

          if (this.level == 1) {
            unlockItems(shopItems, "max targets");
          }

          if (this.level + shopItems.find(item => item.id == "max targets").level == 6) {
            unlockItems(shopItems, "double target spawn", "turtle");
          }

          if (this.level == this.maxLevel) {
            unlockItems(shopItems, "double points");
            this.title = `+${particleBase} Drops Per Target`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "max targets",
        title: "+10 Max Targets",
        unlocked: false,
        level: 0,
        maxLevel: 29,
        price: 30,
        x: undefined,
        y: undefined,
        tooltip: "Increase the maximum amount of normal targets allowed before they stop appearing.",
        onPurchase: function () {
          if (this.level == 1) {
            unlockItems(shopItems, "max potency", "max target width", "unlock garden");
          }
          this.price = Math.round(30 + 30 * this.level ** 1.6);
          maxTargets += 10;
          this.tooltip = "Increase the maximum amount of normal targets allowed before they stop appearing.";

          if (this.level + shopItems.find(item => item.id == "drop per target").level == 6) {
            unlockItems(shopItems, "double target spawn", "turtle");
          }

          if (this.level == this.maxLevel) {
            this.title = `${maxTargets} Max Targets`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "max potency",
        title: "+5% Max Potency",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 100,
        x: undefined,
        y: undefined,
        tooltip: "More colorful targets appear\n\n\n\n* Brighter, more vibrant targets produce more drops when collected.",
        onPurchase: function () {
          if (this.level == 1) {
            unlockItems(shopItems, "super potent chance")
          }
          this.price = 100 + Math.round(50 * this.level ** 2);
          maxNormalPotency += .05;
          this.tooltip = "More colorful targets appear\n\n* Brighter, more vibrant targets produce more drops when collected.";

          if (this.level == this.maxLevel) {
            this.title = `${Math.round(maxNormalPotency * 100)}% Max Potency`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "super potent chance",
        title: "+1% Super Potent Chance",
        unlocked: false,
        level: 0,
        maxLevel: 25,
        price: 50,
        x: undefined,
        y: undefined,
        tooltip: "Increase chance for very bright targets to appear.\n\n* Super-potent targets produce significantly more drops.",
        onPurchase: function () {
          superPotentChance += .01;
          this.price += 50;
          this.tooltip = "Increase chance for very bright targets to appear.\n\n* Super-potent targets produce significantly more drops.";

          if (this.level == this.maxLevel) {
            this.title = `${Math.round(superPotentChance * 100)}% Super Potent Chance`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "max target width",
        title: "+2 Max Target Size",
        unlocked: false,
        level: 0,
        maxLevel: 40,
        price: 25,
        x: undefined,
        y: undefined,
        tooltip: "Larger normal targets can appear\n\n* Larger targets are easier to collect and produce more drops",
        detail: breadthSizeBonus,
        onPurchase: function () {
          this.price = 25 + 15 * this.level;
          breadthSizeBonus += 2;
          this.tooltip = "Larger normal targets can appear\n\n* Larger targets are easier to collect and produce more drops";

          if (this.level == this.maxLevel) {
            this.title = `+${breadthSizeBonus} Max Target Size`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      //#endregion

      //#region intermediate upgrades
      {
        id: "double target spawn",
        title: "x2 Target Spawn Rate",
        unlocked: false,
        level: 0,
        maxLevel: 6,
        price: 100,
        x: undefined,
        y: undefined,
        tooltip: `Double normal target spawn chance`,
        onPurchase: function () {
          if (this.level == 1) {
            unlockItems(shopItems, "unlock dark target")
          }

          this.price *= 5;
          targetChance *= 2;
          this.tooltip = `Double normal target spawn chance`;

          if (this.level == this.maxLevel) {
            this.title = `x${2 ** this.level} Target Spawn Rate`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      
      // dark
      {
        id: "unlock dark target",
        title: "Unlock Dark Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 200,
        x: undefined,
        y: undefined,
        tooltip: "\"Dark\" targets may appear\n\nSPECIAL: produce drops which, then, produce normal targets\n\n* All special targets may appear at the same time; this will not reduce the chance for an explosive target",
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          darkTargetUnlocked = true;
          spawnTarget(null, null, "dark");
          unlockItems(shopItems, "more dark targets", "double dark drops", "unlock explosive target", "max special targets");
          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more dark targets",
        title: "20% More Dark Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 200,
        x: undefined,
        y: undefined,
        tooltip: "Increase the spawn rate of dark targets",
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          darkTargetChance *= 1.2;

          this.tooltip = "Increase the spawn rate of dark targets";

          if (this.level == this.maxLevel) {
            this.title = "More Dark Targets";
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "double dark drops",
        title: "2x Dark Drops",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 1000,
        x: undefined,
        y: undefined,
        tooltip: "Double the number of target-spawning drops from dark targets",
        unlocked: false,
        onPurchase: function () {
          darkTargetConfettiMult *= 2;
          this.price *= 3;

          this.tooltip = "Double the number of target-spawning drops from dark targets";

          if (this.level == this.maxLevel) {
            this.title = `x${darkTargetConfettiMult} Dark Drops`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },

      // explosive
      {
        id: "unlock explosive target",
        title: "Unlock Explosive Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 500,
        x: undefined,
        y: undefined,
        tooltip: "\"Explosive\" targets may appear\n\nSPECIAL: release shrapnel which collects surrounding targets",
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          explosiveTargetUnlocked = true;
          
          spawnTarget(null, null, "explosive");
          unlockItems(shopItems, "more explosive targets", "double explosive target drops", "unlock gold target", "double special target rate");

          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more explosive targets",
        title: "20% More Explosive Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 400,
        x: undefined,
        y: undefined,
        tooltip: "Increase the spawn rate of explosive targets",
        onPurchase: function () {
          explosiveTargetChance *= 1.2;
          this.price = Math.round(this.price * 1.2);

          this.tooltip = "Increase the spawn rate of explosive targets";

          if (this.level == this.maxLevel) {
            this.title = "More Explosive Targets";
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "double explosive target drops",
        title: "x2 Explosive Shrapnel",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 1200,
        x: undefined,
        y: undefined,
        tooltip: "Double the amount of target-collecting shrapnel released from explosive targets",
        unlocked: false,
        onPurchase: function () {
          explosiveConfettiMult *= 2;
          this.price *= 5;

          this.tooltip = "Double the amount of target-collecting shrapnel released from explosive targets";

          if (this.level == this.maxLevel) {
            this.title = `x${2 ** this.maxLevel} Explosive Shrapnel`;
            unlockItems(shopItems, "double explosive time");
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "double explosive time",
        title: "Double Explosive Time",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 100000,
        leafPrice: 10000,
        x: undefined,
        y: undefined,
        tooltip: "Double the duration for which explosive target shrapnel can collect targets",
        onPurchase: function () {
          explosiveLifetimeMult *= 2;
        }
      },

      // gold
      {
        id: "unlock gold target",
        title: "Unlock Gold Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 1000,
        x: undefined,
        y: undefined,
        tooltip: "\"Gold\" targets may appear\n\nSPECIAL: produce a trove of high-value drops",
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          goldTargetUnlocked = true;
          spawnTarget(null, null, "gold");
          unlockItems(shopItems, "more gold targets", "double gold target drop", "easy collect gold");
          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more gold targets",
        title: "20% More Gold Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 500,
        x: undefined,
        y: undefined,
        tooltip: "Increase the spawn rate of dark targets",
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          goldTargetChance *= 1.2;

          this.tooltip = "Increase the spawn rate of dark targets";

          if (this.level == this.maxLevel) {
            this.title = "More Gold Targets";
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "double gold target drop",
        title: "2x Gold Target Drop",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 5000,
        x: undefined,
        y: undefined,
        tooltip: "Double the number of high-value drops from gold targets",
        onPurchase: function () {
          goldTargetDrop *= 2;
          this.price *= 5;
          this.tooltip = "Double the number of high-value drops from gold targets";

          if (this.level == this.maxLevel) {
            this.title = `x${goldTargetDrop} Gold Target Drops`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "easy collect gold",
        title: "Easy-Collect Gold",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 10000,
        x: undefined,
        y: undefined,
        tooltip: "Gold targets only require a single touch to fully collect",
        onPurchase: function () {
          goldAutoCollect = true;
          world.areas["main"].autoTargets = [];
        }
      },

      // other special
      {
        id: "double special target rate",
        title: "x2 Special Target Rate",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 1000,
        x: undefined,
        y: undefined,
        tooltip: "Double the rate at which each special target can appear",
        onPurchase: function () {
          this.price *= 10;
          specialTargetRateMult *= 2;

          this.tooltip = "Double the rate at which each special target can appear";

          if (this.level == this.maxLevel) {
            this.title = `x${specialTargetRateMult} Special Target Rate`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "max special targets",
        title: "+1 Max Special Targets",
        unlocked: false,
        level: 0,
        maxLevel: 9,
        price: 1000,
        x: undefined,
        y: undefined,
        tooltip: "More special targets may be present at once",
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          maxSpecialTargets += 1;

          this.tooltip = "More special targets may be present at once";

          if (this.level == this.maxLevel) {
            this.title = `${maxSpecialTargets} Max Special Targets`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      //#endregion

      //#region advanced upgrades
      {
        id: "double points",
        title: "x2 Points",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 300000,
        leafPrice: 1000,
        x: undefined,
        y: undefined,
        tooltip: "Double the value of drops",
        onPurchase: function () {
          this.price += 200000 * this.level;
          this.leafPrice += 3000 * this.level;
          pointsMult *= 2;

          this.tooltip = "Double the value of drops";
          
          if (this.level == this.maxLevel) {
            this.title = `x${pointsMult} Points`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "turtle",
        title: "+1 Turtle",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 100000,
        leafPrice: 10000,
        x: undefined,
        y: undefined,
        tooltip: "A permanant little buddy appears to collect targets in the main area",
        onPurchase: function () {
          settingsItems.find(e => e.id == "shuffle buddies").unlocked = true;
          
          world.areas["main"].particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            xVelocity: turtleSpeed * randomSign(),
            yVelocity: turtleSpeed * randomSign(),
            friction: 0,
            lifespan: Infinity,
            wallBounce: true,
            color: "green",
            isCollector: true,
            movementIsCrucial: true,
            size: 16,
            maxSpeed: turtleSpeed,
          });

          this.tooltip = "A permanant little buddy appears to collect targets in the main area";
          
          this.price *= 5;
          this.leafPrice *= 3;

          if (this.level == this.maxLevel) {
            this.title = `${this.maxLevel} Turtles`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "unlock garden",
        title: "Unlock Garden Area",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 250,
        x: undefined,
        y: undefined,
        tooltip: "Open doors into the garden\n\nUnlock currency: leaves",
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          world.areas["garden"].unlocked = true;
          world.areas["farmers market"].unlocked = true;
          shopItems.splice(shopItems.indexOf(this), 1);
        }
      }
      //#endregion
    ];

    let farmersMarketItems = [
      //#region plot upgrades
      {
        id: "garden plot",
        title: "+1 Garden Plot",
        unlocked: true,
        level: 0,
        maxLevel: maxGardenPlots,
        price: 0,
        leafPrice: 0,
        x: undefined,
        y: undefined,
        tooltip: "Garden plots provide space for 5 rows each (where the crops actually grow)",
        onPurchase: function () {
          gardenPlots.push({
            x: null, y: null,
            wetness: rainDuration > 0 ? Math.trunc(Math.random() * wetRandRange + minWetness) : 0,
            fertility: 0,
            strips: [],
          });

          this.price = Math.round(2500 * this.level ** 1.6);
          this.leafPrice = 100 * this.level;
          const farmersMarketItems = world.areas["farmers market"].items;

          this.tooltip = "Garden plots provide space for 5 rows each (where the crops actually grow)";

          if (this.level == 1) unlockItems(farmersMarketItems, "garden row", "water plot", "enrich plot");

          
          if (this.level == 5) unlockItems(farmersMarketItems, "sunlamp", "unlock rain");
          if (this.level == this.maxLevel) {
            this.title = `${gardenPlots.length} Garden Plots`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }

          // update the water + enrich upgrades
          farmersMarketItems.find(item => item.id == "water plot").refresh();
          farmersMarketItems.find(item => item.id == "enrich plot").refresh();

          // update the rows upgrade
          farmersMarketItems.find(item => item.id == "garden row").maxLevel = gardenPlots.length * 5;
        }
      },
      {
        id: "garden row",
        title: "+1 Garden Row",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 0,
        leafPrice: 0,
        x: undefined,
        y: undefined,
        detail: null,
        tooltip: "Rows designate space to grow crops repeatedly",
        onPurchase: function () {
          this.price = Math.round(500 * this.level ** 1.5);
          this.leafPrice = 20 * this.level;
          this.tooltip = "Rows designate space to grow crops repeatedly";

          let gardenStripCount = 0;
          for (let i = 0; i < gardenPlots.length; i++) {
            gardenStripCount += gardenPlots[i].strips.length;
          }

          gardenPlots[Math.floor(gardenStripCount / 5)].strips.push([{
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          },]);

          if (this.level == 1) {
            unlockItems(world.areas["farmers market"].items, "crop harvest", "rabbit");
          }
          if (this.level == this.maxLevel) {
            this.title = `${gardenStripCount + 1} Garden Rows`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "water plot",
        title: "Water 1 Plot",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 1000,
        leafPrice: 10,
        x: undefined,
        y: undefined,
        tooltip: "Watered plots dry up over time, but increase crop growth",
        onPurchase: function () {
          this.purchasedBefore = true;
          for (let i = 0; i < gardenPlots.length; i++) {
            const plot = gardenPlots[i];
            if (plot.wetness < 1) {
              plot.wetness = Math.trunc(Math.random() * wetRandRange + minWetness);
              break;
            };
          }
          this.refresh();
        },
        refresh: function () {
          this.maxLevel = gardenPlots.length;
          this.level = gardenPlots.filter(plot => plot.wetness).length;
          this.price = 1000 + 2000 * this.level;
          this.leafPrice = 10 + 10 * this.level;

          this.tooltip = "Watered plots dry up over time, but increase crop growth";

          if (this.level == this.maxLevel) {
            this.title = "All Plots Watered";
          } else {
            this.title = "Water 1 Plot";
          }            
          this.tooltip += `\n\n${this.level}/${this.maxLevel}`;
        },
      },
      {
        id: "enrich plot",
        title: "Enrich 1 Plot",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 3000,
        leafPrice: 20,
        x: undefined,
        y: undefined,
        tooltip: "Fertile plots increase crop growth for a number of harvests, but eventually run out",
        onPurchase: function () {
          this.purchasedBefore = true;
          for (let i = 0; i < gardenPlots.length; i++) {
            const plot = gardenPlots[i];
            if (!plot.fertility) {
              plot.fertility = fertilizerAmount;
              break;
            }
          }
          this.refresh();
        },
        refresh: function () {
          this.maxLevel = gardenPlots.length;
          this.level = gardenPlots.filter(plot => plot.fertility).length;
          this.price = 3000 + 3000 * this.level;
          this.leafPrice = 20 + 10 * this.level;

          this.tooltip = "Fertile plots increase crop growth for a number of harvests, but eventually run out";

          if (this.level == this.maxLevel) {
            this.title = "All Plots Enriched";
          } else {
            this.title = "Enrich 1 Plot";
          }
          this.tooltip += `\n\n${this.level}/${this.maxLevel}`;
        },
      },
      //#endregion

      //#region general upgrades
      {
        id: "crop harvest",
        title: "+1 Crop Harvest",
        unlocked: false,
        level: 0,
        maxLevel: 9,
        price: 1000,
        leafPrice: 10,
        x: undefined,
        y: undefined,
        tooltip: "Crops produce more drops",
        onPurchase: function () {
          cropHarvestBonus += 1;
          this.price = 1000 + 2000 * this.level;
          this.leafPrice *= 2;

          this.tooltip = "Crops produce more drops";

          if (this.level == this.maxLevel) {
            this.title = `+${cropHarvestBonus} Crop Harvest`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      {
        id: "sunlamp",
        title: "Install Sunlamp",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 200000,
        leafPrice: 2500,
        x: undefined,
        y: undefined,
        tooltip: "Double crop growth",
        onPurchase: function () {
          cropGrowthChance *= 2;
          this.title = "Sunlamp";
        }
      },
      {
        id: "unlock rain",
        title: "Unlock Rain",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 200000,
        leafPrice: 1000,
        x: undefined,
        y: undefined,
        tooltip: "\"Rain\" targets may appear in the garden\n\nSPECIAL: begin the rain event which waters plots for a little while",
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          rainUnlocked = true;
          spawnTarget(null, null, "rain");
          unlockItems(settingsItems, "show rain");
        }
      },
      {
        id: "rabbit",
        title: "+1 Rabbit",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 500,
        leafPrice: 30,
        x: undefined,
        y: undefined,
        tooltip: "A permanant little buddy appears to collect targets and crops in the garden",
        onPurchase: function () {
          settingsItems.find(e => e.id == "shuffle buddies").unlocked = true;

          world.areas["garden"].particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            xVelocity: rabbitSpeed * randomSign(),
            yVelocity: rabbitSpeed * randomSign(),
            friction: 0,
            lifespan: Infinity,
            wallBounce: true,
            color: "white",
            stroke: "gray",
            isCollector: true,
            movementIsCrucial: true,
            size: 16,
            maxSpeed: rabbitSpeed,
          });
          this.price *= 20;
          this.leafPrice *= 10;

          this.tooltip = "A permanant little buddy appears to collect targets and crops in the garden";

          if (this.level == this.maxLevel) {
            this.title = `${this.level} Rabbits`;
            this.tooltip += `\n\nLevel: ${this.level}`;
          } else {
            this.tooltip += `\n\nLevel: ${this.level}/${this.maxLevel}`;
          }
        }
      },
      //#endregion
    ];

    
    let settingsItems = [
      {
        id: "allow touch controls",
        title: "Touch Controller",
        unlocked: userHasTouchScreen,
        enabled: true,
        x: undefined,
        y: undefined,
        tooltip: "Determine whether or not the touch controller is displayed\n\n* Alternative movement uses keyboard (arrow keys/WASD) or joystick\n\nPerformance impact: miniscule\n\nENABLED",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;

          if (this.enabled) {
            unlockItems(settingsItems, "controller size", "use joystick");
          } else {
            lockItems(settingsItems, "controller size", "use joystick");
          }

          // external impact
          if (settingsItems.find(e=>e.id == "use joystick").enabled) {
            document.getElementById("joystick-area").style.display = this.enabled ? "block" : "none";
          } else {
            document.getElementById("touch-arrow-controller").style.display = this.enabled ? "grid" : "none";
          }
          useTouchController = this.enabled;

          // item update
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.tooltip = `Determine whether or not the touch controller is displayed\n\n* Alternative movement uses keyboard (arrow keys/WASD) or joystick\n\nPerformance impact: miniscule\n\n${this.enabled ? "ENABLED" : "DISABLED"}`;
        }
      },
      {
        id: "controller size",
        title: "Controller Size",
        unlocked: userHasTouchScreen,
        level: 1,
        x: undefined,
        y: undefined,
        tooltip: "Determine the size of the touch controller\n\nPerformance impact: none\n\nMEDIUM",
        color: "gold",
        onPurchase: function () {
          this.level = (this.level + 1) % 3;

          touchControllerSize = [
            ()=>{return Math.min(window.innerWidth, window.innerHeight) / 3}, 
            ()=>{return Math.min(window.innerWidth, window.innerHeight) / 2}, 
            ()=>{return Math.min(window.innerWidth, window.innerHeight) / 1.3}
          ][this.level];

          updateTouchControllers(touchControllerSize());

          this.color = ["rgb(200, 0, 0)", "gold", "rgb(0, 200, 0)"][this.level];
          this.tooltip = `Determine the size of the touch controller\n\nPerformance impact: none\n\n${["SMALL", "MEDIUM", "LARGE"][this.level]}`;
        }
      },
      {
        id: "use joystick",
        title: "Use Joystick",
        unlocked: userHasTouchScreen,
        enabled: true,
        x: undefined,
        y: undefined,
        tooltip: "Determine whether the touch controller uses joystick or arrow inputs\n\nPerformance impact: none\n\nJOYSTICK",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;

          useTouchJoystick = this.enabled;
          const joystick = document.getElementById("joystick-area");
          if (useTouchJoystick) {
            unlockItems(settingsItems, "joystick area");
            lockItems(settingsItems, "lock controller");
            joystick.style.display = "block";
          } else {
            lockItems(settingsItems, "joystick area");
            unlockItems(settingsItems, "lock controller");
            joystick.style.display = "none";
          }
          updateTouchControllers(touchControllerSize());

          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.tooltip = `Determine whether the touch controller uses joystick or arrow inputs\n\nPerformance impact: none\n\n${this.enabled ? "JOYSTICK" : "ARROWS"}`;
        }
      },
      {
        id: "joystick area",
        title: "Joystick Area",
        unlocked: userHasTouchScreen,
        enabled: true,
        x: undefined,
        y: undefined,
        tooltip: "Determine which side of the screen the joystick control is used on\n\nPerformance impact: none\n\nLEFT",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;

          const joystick = document.getElementById("joystick-area");
          if (this.enabled) {
            joystick.style.left = "0px";
            joystick.style.right = null;
          } else {
            joystick.style.left = null;
            joystick.style.right = "0px";
          }

          // display effect
          const duration = 900;
          joystick.style.transitionDuration = "0ms";
          joystick.style.backgroundColor = "rgba(0, 0, 0, 0.54)";
          setTimeout(()=>joystick.style.transitionDuration = `${duration}ms`, 0);
          setTimeout(()=>joystick.style.backgroundColor = "rgba(0, 0, 0, 0)", 0); 

          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.tooltip = `Determine which side of the screen the joystick control is used on\n\nPerformance impact: none\n\n${this.enabled ? "LEFT" : "RIGHT"}`;
        }
      },
      {
        id: "lock controller",
        title: "Lock Controller",
        unlocked: false,
        enabled: true,
        x: undefined,
        y: undefined,
        tooltip: "Determine whether the arrow controller can be moved\n\nPerformance impact: none\n\nUNLOCKED",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          document.getElementById("adjust-controller").style.display = this.enabled ? "grid" : "none";
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.tooltip = `Determine whether the arrow controller can be moved\n\nPerformance impact: none\n\n${this.enabled ? "UNLOCKED" : "LOCKED"}`;
        }
      },
      {
        id: "show version",
        title: "Show Version Code",
        unlocked: true,
        enabled: true,
        x: undefined,
        y: undefined,
        tooltip: "Determine whether the game version shows in the corner\n\nPerformance impact: miniscule\n\nSHOWN",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          showVersionCode = this.enabled;
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.tooltip = `Determine whether the game version shows in the corner\n\nPerformance impact: miniscule\n\n${this.enabled ? "SHOWN" : "HIDDEN"}`;
        }
      },
      {
        id: "show currency",
        title: "Show Currency",
        unlocked: true,
        enabled: true,
        x: undefined,
        y: undefined,
        detail: "shown",
        tooltip: "Determine whether game currencies are actively displayed on screen\n\nPerformance impact: miniscule\n\nSHOWN",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          showCurrency = this.enabled;
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.tooltip = `Determine whether game currencies are actively displayed on screen\n\nPerformance impact: miniscule\n\n${this.enabled ? "SHOWN" : "HIDDEN"}`;
        }
      },
      {
        id: "show drops",
        title: "Show Drops",
        unlocked: true,
        level: 2,
        x: undefined,
        y: undefined,
        tooltip: `Determine whether normal target drops are rendered\n\nPerformance impact: medium\n\nSHOWN`,
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.level = (this.level + 1) % 3;

          showDrops = this.level;
          this.color = ["rgb(200, 0, 0)", "gold", "rgb(0, 200, 0)"][this.level];
          this.tooltip = `Determine whether normal target drops are rendered\n\nPerformance impact: medium\n\n${["NONE", "SOME", "ALL"][this.level]}`;

          if (showDrops) {
            unlockItems(settingsItems, "drop time");
          } else {
            lockItems(settingsItems, "drop time");
          }
        }
      },
      {
        id: "drop time",
        title: "Drop Collect Speed",
        unlocked: true,
        level: 1,
        x: undefined,
        y: undefined,
        tooltip: `Determine how quickly most drops disappear\n\nPerformance impact: medium\n\nMEDIUM`,
        color: "orange",
        onPurchase: function () {
          this.level = (this.level + 1) % 4;
          normalParticleTime = [2, 1, .25, .1][this.level];
          this.color = ["rgb(200, 0, 0)", "orange", "gold", "rgb(0, 200, 0)"][this.level];
          this.tooltip = `Determine how quickly most drops disappear\n\nPerformance impact: medium\n\n${["SLOW", "MEDIUM", "FAST", "REALLY FAST"][this.level]}`;
        }
      },
      {
        id: "show particles",
        title: "Show Particles",
        unlocked: true,
        level: 2,
        x: undefined,
        y: undefined,
        tooltip: `Determine whether cosmetic particles are rendered\n\nPerformance impact: medium\n\nALL`,
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.level = (this.level + 1) % 3;

          showCosmeticParticles = this.level;
          this.color = ["rgb(200, 0, 0)", "gold", "rgb(0, 200, 0)"][this.level];
          this.tooltip = `Determine whether cosmetic particles are rendered\n\nPerformance impact: medium\n\n${["NONE", "SOME", "ALL"][this.level]}`;
        }
      },
      {
        id: "show targets",
        title: "Show Targets",
        unlocked: true,
        level: 3,
        x: undefined,
        y: undefined,
        tooltip: `Determine which targets to render\n\nPerformance impact: low-medium\n\nALL`,
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.level = (this.level + 1) % 4;

          showNormalTargets = [false, true, false, true][this.level];
          showSpecialTargets = [false, false, true, true][this.level];

          this.color = ["rgb(200, 0, 0)", "orange", "gold", "rgb(0, 200, 0)"][this.level];
          this.tooltip = `Determine which targets to render\n\nPerformance impact: low-medium\n\n${["NONE", "ONLY NORMAL TARGETS", "ONLY SPECIAL TARGETS", "ALL"][this.level]}`;
        }
      },
      {
        id: "target limit",
        title: "Limit Targets",
        unlocked: true,
        enabled: false,
        x: undefined,
        y: undefined,
        tooltip: `Determine if the normal target count is allowed to overflow its maximum (ie. due to dark targets)\n\n* For balancing, this option reduces dark target spawns when enabled\n\nPerformance improvement when strict: low-high\n\nNORMAL`,
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          strictTargetAmountLimit = this.enabled;
          this.color = this.enabled ? "rgb(200, 0, 0)" : "rgb(0, 200, 0)";
          this.tooltip = `Determine if the normal target count is allowed to overflow its maximum (ie. due to dark targets)\n\n* For balancing, this option reduces dark target spawns when enabled\n\nPerformance improvement when strict: low-high\n\n${this.enabled ? "STRICT" : "NORMAL"}`;
        }
      },
      {
        id: "show doors",
        title: "Show Doorways",
        unlocked: true,
        level: 3,
        x: undefined,
        y: undefined,
        tooltip: `Determine how doorways should be displayed\n\nPerformance impact: miniscule\n\nLABELS & DOORWAYS`,
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.level = (this.level + 1) % 4;

          if (this.level == 0) {
            showDoorway = false;
            showDoorLabel = false;
          } else if (this.level == 1) {
            showDoorway = true;
            showDoorLabel = false;
          } else if (this.level == 2) {
            showDoorway = false;
            showDoorLabel = true;
          } else if (this.level == 3) {
            showDoorway = true;
            showDoorLabel = true;
          }

          this.color = ["rgb(200, 0, 0)", "orange", "gold", "rgb(0, 200, 0)"][this.level];
          this.tooltip = `Determine how doorways should be displayed\n\nPerformance impact: miniscule\n\n${["NONE", "DOORWAYS", "LABELS", "LABELS & DOORWAYS"][this.level]}`;
        }
      },
      {
        id: "door size",
        title: "Door Size",
        unlocked: true,
        level: 1,
        x: undefined,
        y: undefined,
        tooltip: `Change the physical size of doors\n\nPerformance impact: none\n\nMEDIUM`,
        color: "gold",
        onPurchase: function () {
          this.level = (this.level + 1) % 3;

          doorSize = [40, 70, 100][this.level];

          this.color = ["rgb(200, 0, 0)", "gold", "rgb(0, 200, 0)"][this.level];
          this.tooltip = `Change the physical size of doors\n\nPerformance impact: none\n\n${["SMALL", "MEDIUM", "LARGE"][this.level]}`;
        }
      },
      {
        id: "show rain",
        title: "Show Rain",
        unlocked: false,
        enabled: true,
        x: undefined,
        y: undefined,
        tooltip: `Determine whether cosmetic rain particles appear in the garden during rain events\n\nPerformance impact: low\n\nSHOWN`,
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          showRain = this.enabled;
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.tooltip = `Determine whether cosmetic rain particles appear in the garden during rain events\n\nPerformance impact: low\n\n${this.enabled ? "SHOWN" : "HIDDEN"}`;
        }
      },
      {
        id: "shuffle buddies",
        title: "Shuffle Buddies",
        unlocked: false,
        x: undefined,
        y: undefined,
        tooltip: `Instantly scramble the positions of all rabbits and turtles\n\n* Useful if they have poor positioning`,
        color: "rgb(0, 200, 0)",
        debounce: false,
        onPurchase: function () {
          if (this.debounce) return;

          for (let i = 0; i < Object.keys(world.areas).length; i++) {
            const area = world.areas[Object.keys(world.areas)[i]];
            
            if (!area.particles) continue;
            for (let j = 0; j < area.particles.length; j++) {
              const particle = area.particles[j];

              if (isFinite(particle.lifespan) || !particle.isCollector) continue;
              
              particle.xVelocity = particle.maxSpeed * randomSign();
              particle.yVelocity = particle.maxSpeed * randomSign();

              particle.x = Math.trunc(Math.random() * canvas.width);
              particle.y = Math.trunc(Math.random() * canvas.height);
            } 
          }

          this.debounce = true;
          this.color = "rgb(200, 0, 0)";
          setTimeout(() => {
            this.debounce = false;
            this.color = "rgb(0, 200, 0)";
          }, 300);
        }
      },
    ];
    
    const world = {
      scene: "main",
      areas: {
        "main": new Area([new Door("right", "garden"), new Door("left", "garden"), new Door("bottom", "shop")], [], [], null, "white", true),
        "shop": new Area([new Door("right", "farmers market"), new Door("left", "farmers market"), new Door("top", "main"), new Door("top", "settings", .8)], [], null, shopItems, "rgb(240, 225, 200)", true),
        "garden": new Area([new Door("right", "main"), new Door("left", "main"), new Door("bottom", "farmers market")], [], [], null, "rgb(200, 255, 200)"),
        "farmers market": new Area([new Door("right", "shop"), new Door("left", "shop"), new Door("top", "garden"), new Door("top", "settings", .2)], [], null, farmersMarketItems, "rgb(200, 255, 200)"),
        "settings": new Area([new Door("bottom", "farmers market", .2), new Door("bottom", "shop", .8)], [], null, settingsItems, "white", true),
      },
    }
    world.areas["main"].specialTargets = [];
    world.areas["garden"].specialTargets = [];
    
    //#region collisions
    const doCollisions = (collider, area) => {
      if (area.targets) {
        for (let i = 0; i < area.targets.length; i++) {
          const target = area.targets[i];
          if (rectsDoCollide(collider, target)) collectTarget(target);
        }
      }
      if (area.specialTargets) {
        for (let i = 0; i < area.specialTargets.length; i++) {
          const target = area.specialTargets[i];
          if (rectsDoCollide(collider, target)) collectTarget(target);
        }
      }

      let didCollideItem = false;
      if (area.items) {
        shopFocus = undefined;
        
        for (let i = 0; i < area.items.length; i++) {
          const item = area.items[i];
          
          if (rectsDoCollide(collider, { ...item, size: itemButtonSize })) {
            didCollideItem = true;
            showTooltip(item);            
            if (purchaseIsValid(item)) shopFocus = item;
            break;
          }
        }
      }
      if (!didCollideItem) hideTooltip();

      // garden collisions (crop targets are organized differently data-wise)
      if (area == world.areas["garden"]) {
        for (let i = 0; i < gardenPlots.length; i++) {
          const plot = gardenPlots[i];
          for (let j = 0; j < plot.strips.length; j++) {
            const strip = plot.strips[j];
            for (let k = 0; k < strip.length; k++) {
              const crop = strip[k];

              if (crop.growth >= 1 && rectsDoCollide(collider, { x: crop.x, y: crop.y, size: maxCropSize })) {
                harvestCrop(crop);
                // if not zero, -1, then, if zero, update shop item
                if (plot.fertility && !--plot.fertility) farmersMarketItems.find(e => e.id == "enrich plot").refresh();
              }
            }
          }
        }
      }
    }

    const rectsDoCollide = (rect1, rect2) => {
      const r1Half = rect1.size / 2;
      const r1 = {
        top: rect1.y - r1Half,
        bottom: +rect1.y + r1Half,
        right: +rect1.x + r1Half,
        left: rect1.x - r1Half,
      }

      const r2Half = rect2.size / 2;
      const r2 = {
        top: rect2.y - r2Half,
        bottom: +rect2.y + r2Half,
        right: +rect2.x + r2Half,
        left: rect2.x - r2Half,
      }

      return (r1.left < r2.right && r1.left > r2.left || r1.right > r2.left && r1.right < r2.right) && (r1.top < r2.bottom && r1.top > r2.top || r1.bottom > r2.top && r1.bottom < r2.bottom);
    }
    //#endregion

    //#region player
    const setupPlayerControls = () => {
      document.body.addEventListener("contextmenu", e => e.preventDefault());

      setupKeyboardControls();

      addTouchListeners();
      updateTouchControllers(touchControllerSize());
      document.getElementById("joystick-area").style.left = "0px";
      
      window.addEventListener("gamepadconnected", logGamepadStatus);
    }

    const setupKeyboardControls = () => {
      window.addEventListener("keydown", (event) => {
        const key = event.key.toLowerCase();
        
        // set controller
        if (key == "w" || key == "arrowup") controller.up = true;
        if (key == "a" || key == "arrowleft") controller.left = true;
        if (key == "s" || key == "arrowdown") controller.down = true;
        if (key == "d" || key == "arrowright") controller.right = true;
        if (key == "e" || key == " ") controller.interact = true;
      });
      window.addEventListener("mousedown", e => controller.interact = true);
      window.addEventListener("mouseup", e => controller.interact = false);
      canvas.addEventListener("touchstart", e => controller.interact = true);
      window.addEventListener("touchend", e => controller.interact = false);
      window.addEventListener("touchcancel", e => controller.interact = false);

      window.addEventListener("keyup", (event) => {
        const key = event.key.toLowerCase();

        // set controller
        if (key == "w" || key == "arrowup") controller.up = false;
        if (key == "a" || key == "arrowleft") controller.left = false;
        if (key == "s" || key == "arrowdown") controller.down = false;
        if (key == "d" || key == "arrowright") controller.right = false;
        if (key == "e" || key == " ") controller.interact = false;
      });
    }

    const updateTouchControllers = (controllerSize) => {
      if (!useTouchController) return;
      const arrowControl = document.getElementById("touch-arrow-controller");
      
      if (!userHasTouchScreen || useTouchJoystick) {
        const joystickControl = document.getElementById("joystick-area");
        arrowControl.style.display = "none";
        joystickControl.style.display = "block";
        
        const socket = document.getElementById("joystick-socket");
        socket.style.width = controllerSize / 2;
        socket.style.height = controllerSize / 2;
      } else {
        // resize
        const fontSize = controllerSize / 12;
        arrowControl.style.display = userHasTouchScreen ? "grid" : "none";
        arrowControl.style.gap = controllerSize / 50 + "px";
        arrowControl.style.height = controllerSize + "px";
        arrowControl.style.width = controllerSize + "px";
        arrowControl.style.fontSize = fontSize + "px";
  
        console.log(canvas.getBoundingClientRect())
        // reposition
        arrowControl.style.left = canvas.getBoundingClientRect().left + "px";
        arrowControl.style.bottom = window.innerHeight - canvas.getBoundingClientRect().height + "px";
      }
      
      // refresh event listeners
      removeTouchListeners();
      addTouchListeners();
    }

    //#region event listeners
    const removeTouchListeners = () => {
      const arrowController = document.getElementById("touch-arrow-controller");
      const adjustmentControl = document.getElementById("adjust-controller");
      
      adjustmentControl.removeEventListener("touchmove", adjustController);
      adjustmentControl.removeEventListener("touchend", putControllerBack);
      adjustmentControl.removeEventListener("touchcancel", putControllerBack);
      
      ["up", "left", "right", "down"].forEach(direction => {
        const control = arrowController.children[direction];
        control.removeEventListener("touchstart", e => controllerDirectionOn(e, direction));
        control.removeEventListener("touchend", e => controllerDirectionOff(e, direction));
        control.removeEventListener("touchcancel", e => controllerDirectionOff(e, direction));
      })

      const joystick = document.getElementById("joystick-area");
      joystick.removeEventListener("touchmove", moveTouchJoystick);
      joystick.removeEventListener("touchend", releaseTouchJoystick);
      joystick.removeEventListener("touchcancel", releaseTouchJoystick);
    }

    const addTouchListeners = () => {
      const arrowController = document.getElementById("touch-arrow-controller");
      const adjustmentControl = document.getElementById("adjust-controller");

      adjustmentControl.addEventListener("touchmove", adjustController);
      adjustmentControl.addEventListener("touchend", putControllerBack);
      adjustmentControl.addEventListener("touchcancel", putControllerBack);
      
      ["up", "left", "right", "down"].forEach(direction => {
        const control = arrowController.children[direction];
        control.addEventListener("touchstart", e => controllerDirectionOn(e, direction));
        control.addEventListener("touchend", e => controllerDirectionOff(e, direction));
        control.addEventListener("touchcancel", e => controllerDirectionOff(e, direction));
      });
      
      const joystick = document.getElementById("joystick-area");
      joystick.addEventListener("touchmove", moveTouchJoystick);
      joystick.addEventListener("touchend", releaseTouchJoystick);
      joystick.addEventListener("touchcancel", releaseTouchJoystick);
    }
    
    const moveTouchJoystick = e => {
      const touch = e.changedTouches[0];
      const areaRect = document.getElementById("joystick-area").getBoundingClientRect();
      const socket = document.getElementById("joystick-socket");
      const thumb = document.getElementById("joystick-thumb");
      
      const touchPoint = new Point(touch.clientX - areaRect.left, touch.clientY);
      if (!joystickStart) {
        joystickStart = touchPoint;
        
        socket.style.left = joystickStart.x + "px";
        socket.style.top = joystickStart.y + "px";
      };
      
      const socketRect = socket.getBoundingClientRect();
      const controllerPoint = new Point(socketRect.x + (socketRect.width / 2) - areaRect.left, socketRect.y + (socketRect.height / 2));
      
      const vector = Vector.fromPoints(controllerPoint, touchPoint);
      vector.magnitude = Math.min(vector.magnitude / socketRect.width, 1);
      controller.joystick = vector;

      const dx = vector.magnitude * Math.cos(vector.direction);
      const dy = vector.magnitude * Math.sin(vector.direction);

      // move the joystick thumb
      socket.style.display = "grid";
      thumb.style.transform = `translate(${dx * socketRect.width}px, ${dy * socketRect.height}px)`;
    }
    const releaseTouchJoystick = e => {
      controller.joystick = null;
      joystickStart = null;
      const thumb = document.getElementById("joystick-thumb");
      const socket = document.getElementById("joystick-socket");
      socket.style.display = "none";
      thumb.style.transform = "translate(0, 0)";
    }

    const controllerDirectionOn = (e, direction) => {
      controller[direction] = true;
    }
    const controllerDirectionOff = (e, direction) => {
      controller[direction] = false;
    }
    const putControllerBack = e => {
      const touchController = document.getElementById("touch-arrow-controller");
      const quarterController = touchControllerSize() / 4;
      const rect = touchController.getBoundingClientRect();

      if (rect.left < -quarterController || rect.right > window.innerWidth + quarterController || rect.top < -quarterController || rect.bottom > window.innerHeight + quarterController) {
        updateTouchControllers(touchControllerSize());
      }
    }
    const adjustController = e => {
      const touch = e.changedTouches[0];
      const touchController = document.getElementById("touch-arrow-controller");
      const halfController = touchControllerSize() / 2;
      touchController.style.left = `${touch.clientX - halfController}px`;
      touchController.style.top = `${touch.clientY - halfController}px`;
    }

    const logGamepadStatus = e => {
      console.log(e);
    }
    //#endregion

    const drawPlayer = () => {
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x - (player.size / 2), player.y - (player.size / 2), player.size, player.size);
    }

    const movePlayer = deltaT => {
      const move = player.movement;
      const targetSpeed = player.targetSpeed;

      // Accelerate
      if (controller.joystick) {
        const adjustedMagnitude = controller.joystick.magnitude * player.acceleration * deltaT;
        player.movement = addVectors(player.movement, new Vector(adjustedMagnitude, controller.joystick.direction));
      };

      if (controller.up) player.movement = addVectors(player.movement, new Vector(player.acceleration * deltaT, -Math.PI / 2));
      if (controller.left) player.movement = addVectors(player.movement, new Vector(player.acceleration * deltaT, Math.PI));
      if (controller.down) player.movement = addVectors(player.movement, new Vector(player.acceleration * deltaT, Math.PI / 2));
      if (controller.right) player.movement = addVectors(player.movement, new Vector(player.acceleration * deltaT, 0));


      if (!controller.joystick && !controller.up && !controller.down && !controller.left && !controller.right) {
        // Decelerate
        if (player.movement.magnitude > 0) {
          const frictionVector = new Vector(player.friction * deltaT, player.movement.direction);
          player.movement = subtractVectors(player.movement, frictionVector);
        }
        
        // Limit
        if (player.movement.magnitude < 1) {
          player.movement.magnitude = 0;
        } 
      }
      player.movement.magnitude = Math.min(player.maxSpeed, player.movement.magnitude);

      // Move
      player.x += player.movement.magnitude * Math.cos(player.movement.direction) * deltaT;
      player.y += player.movement.magnitude * Math.sin(player.movement.direction) * deltaT;

      handleDoorInteractions(deltaT);
    }
    //#endregion

    const handleDoorInteractions = deltaT => {
      let moveTo;

      if (player.x > canvas.width) {
        const doors = world.areas[scene].doors.filter(door => door.side == "right" && world.areas[door.destination].unlocked);
        for (let i = 0; i < doors.length; i++) {
          const door = doors[i];
          const doorPosition = door.position ? canvas.height * door.position : canvas.height / 2;

          if (player.y < doorPosition + doorSize && player.y > doorPosition - doorSize) {
            scene = door.destination;
            player.x = 20;
            break;
          }
        }

        moveTo = new Point(player.x - player.maxSpeed * 2 * deltaT, player.y);
      }

      if (player.x < 0) {
        const doors = world.areas[scene].doors.filter(door => door.side == "left" && world.areas[door.destination].unlocked);
        for (let i = 0; i < doors.length; i++) {
          const door = doors[i];
          const doorPosition = door.position ? canvas.height * door.position : canvas.height / 2;

          if (player.y < doorPosition + doorSize && player.y > doorPosition - doorSize) {
            scene = door.destination;
            player.x = canvas.width - 20;
            break;
          }
        }

        moveTo = new Point(player.x + player.maxSpeed * 2 * deltaT, player.y);
      }

      if (player.y > canvas.height) {
        const doors = world.areas[scene].doors.filter(door => door.side == "bottom" && world.areas[door.destination].unlocked);
        for (let i = 0; i < doors.length; i++) {
          const door = doors[i];
          const doorPosition = door.position ? canvas.width * door.position : canvas.width / 2;

          if (player.x < doorPosition + doorSize && player.x > doorPosition - doorSize) {
            scene = door.destination;
            player.y = 20;
            break;
          }
        }
      
        moveTo = new Point(player.x, player.y - player.maxSpeed * 2 * deltaT);
      }

      if (player.y < 0) {
        const doors = world.areas[scene].doors.filter(door => door.side == "top" && world.areas[door.destination].unlocked);
        for (let i = 0; i < doors.length; i++) {
          const door = doors[i];
          const doorPosition = door.position ? canvas.width * door.position : canvas.width / 2;

          if (player.x < doorPosition + doorSize && player.x > doorPosition - doorSize) {
            scene = door.destination;
            player.y = canvas.height - 20;
            break;
          }
        }

        moveTo = new Point(player.x, player.y + player.maxSpeed * 2 * deltaT);
      }

      // keep the player on screen
      if (moveTo) {
        const newVector = Vector.fromPoints(player, moveTo);
        newVector.magnitude = 2 * player.acceleration;
        player.movement = addVectors(player.movement, newVector);
      }
    }

    //#region particles
    const moveParticles = deltaT => {
      deltaT *= gameSpeed;
      const areaNames = Object.keys(world.areas);
      for (let i = 0; i < areaNames.length; i++) {
        const area = world.areas[areaNames[i]];
        
        for (let j = 0; j < area.particles.length; j++) {
          const particle = area.particles[j];

          if (particle.type && particle.type == "rain") {
            if (!showRain || scene != areaNames[i]) continue;
          } else if (particle.isCosmetic) {
            if (!showCosmeticParticles || scene != areaNames[i]) continue;
          } else {
            if (!showDrops && isFinite(particle.lifespan) && !particle.movementIsCrucial)  {
              if (particle.onDeath) particle.onDeath();
              area.particles.splice(j, 1);
              continue;
            }
          }
          
          // keep the particle on screen
          if (!particle.ignoreWalls) {
            if (particle.wallBounce) {
              if (particle.x > canvas.width) particle.xVelocity = -Math.abs(particle.xVelocity);
              else if (particle.x < 0) particle.xVelocity = Math.abs(particle.xVelocity);
              if (particle.y > canvas.height) particle.yVelocity = -Math.abs(particle.yVelocity);
              else if (particle.y < 0) particle.yVelocity = Math.abs(particle.yVelocity);
            } else {
              if (particle.x > canvas.width) particle.xVelocity -= 2 * deltaT;
              else if (particle.x < 0) particle.xVelocity += 2 * deltaT;
              if (particle.y > canvas.height) particle.yVelocity -= 2 * deltaT;
              else if (particle.y < 0) particle.yVelocity += 2 * deltaT;
            }
          }

          if (particle.xVelocity || particle.yVelocity) {
            // move
            particle.x += particle.xVelocity * deltaT;
            particle.y += particle.yVelocity * deltaT;

            // apply friction
            const xSign = Math.sign(particle.xVelocity);
            const ySign = Math.sign(particle.yVelocity);

            const speedChangeX = particle.xVelocity + particle.friction * -xSign * deltaT;
            if (xSign == 1) {
              particle.xVelocity = Math.max(speedChangeX, 0);
            } else if (xSign == -1) {
              particle.xVelocity = Math.min(speedChangeX, 0);
            };
            const speedChangeY = particle.yVelocity + particle.friction * -ySign * deltaT;
            if (ySign == 1) {
              particle.yVelocity = Math.max(speedChangeY, 0);
            } else if (ySign == -1) {
              particle.yVelocity = Math.min(speedChangeY, 0);
            };
          }

          if (particle.isCollector) doCollisions({ x: particle.x, y: particle.y, size: particleSize }, area);
          if (particle.onFrame) particle.onFrame();

          // die off
          particle.lifespan -= deltaT;
          if (particle.lifespan <= 0) {
            if (particle.onDeath) particle.onDeath();
            area.particles.splice(j, 1);
          }
        }
      }
    }

    const drawParticles = () => {
      const area = world.areas[scene];
      
      for (let i = 0; i < area.particles.length; i++) {
        const particle = area.particles[i];
        
        if (particle.type && particle.type == "rain") {
          if (!showRain) continue;
        } else if (particle.isCosmetic) {
          if (!showCosmeticParticles) continue;
        } else {
          if (!showDrops && isFinite(particle.lifespan)) continue;
        }
        
        // fadeToTransparent requires hue, saturation, lightness, and maxLifespan
        if (particle.fadeToTransparent) {
          ctx.fillStyle = `hsla(${particle.hue}, ${particle.saturation}%, ${particle.lightness}%, ${(particle.startingTransparency || 1) * (particle.lifespan / particle.maxLifespan)})`;
        } else {
          ctx.fillStyle = particle.color;
        }
        ctx.fillRect(particle.x - particleSize / 2, particle.y - particleSize / 2, particle.size ? particle.size : particleSize, particle.size ? particle.size : particleSize);

        if (particle.stroke) {
          ctx.lineWidth = particle.strokeSize || 1;
          if (ctx.strokeStyle != particle.color) ctx.strokeStyle = particle.color;
          ctx.strokeRect(particle.x - particleSize / 2, particle.y - particleSize / 2, particle.size ? particle.size : particleSize, particle.size ? particle.size : particleSize);
        }
      }
    }
    //#endregion

    //#region targets
    const spawnTarget = (x, y, type) => {
      const main = world.areas["main"];
      const garden = world.areas["garden"];
      
      if (!type) {
        const superPotent = Math.random() < superPotentChance;
        const potency = superPotent ? superPotentValue : Math.random() * maxNormalPotency;
        const breadth = Math.random();
        const confetti = Math.trunc(potency * potencyBonus / 2 + breadth * breadthBonus);

        if (strictTargetAmountLimit && main.targets.length >= maxTargets) {
          points += (confetti + particleBase) * pointsMult;
          return;
        }
        
        const newTarget = {
          x: x ? x : Math.trunc(Math.random() * canvas.width),
          y: y ? y : Math.trunc(Math.random() * canvas.height),
          size: Math.trunc(breadth * breadthSizeBonus + minimumTargetSize),
          color: randomTargetColor(Math.max(potency, .1)),
          confetti: confetti,
          type: type,
          collect: function() {
            const drops = this.confetti + particleBase;
            for (let i = 0; i < drops; i++) {
              if (showDrops == 1 && i % 3 > 0) {
                points += pointsMult;
                continue;
              }

              main.particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * (drops / 3 + 16) - (drops / 6 + 8)),
                yVelocity: Math.trunc(Math.random() * (drops / 3 + 16) - (drops / 6 + 8)),
                friction: 1,
                lifespan: Math.trunc((normalParticleTime + Math.random() * normalParticleTime / 2) * FPS),
                color: this.color,
                onDeath: () => { points += pointsMult },
              });
            }
            
            main.targets.splice(main.targets.indexOf(this), 1);
          }
        };

        if (superPotent) newTarget.stroke = "#ccc";

        main.targets.push(newTarget);
      } else if (type == "dark") {
        const breadth = Math.random();

        const newTarget = {
          x: x ? x : Math.trunc(Math.random() * canvas.width),
          y: y ? y : Math.trunc(Math.random() * canvas.height),
          size: Math.trunc(breadth * 40 + 40),
          color: "black",
          stroke: "white",
          strokeSize: 2,
          confetti: Math.trunc(breadth * breadthBonus),
          type: type,
          collect: function() {
            const maxVelo = 25 + darkTargetConfettiMult * 2;
            for (let i = 0; i < this.confetti + 20 * darkTargetConfettiMult; i++) {
              // spawn particles that become new generic targets
              main.particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
                yVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
                friction: 1,
                lifespan: Math.trunc((2 + Math.random()) / 2 * FPS),
                color: this.color,
                movementIsCrucial: true,
                onDeath: function () { spawnTarget(this.x, this.y) },
              });
            }

            main.specialTargets.splice(main.specialTargets.indexOf(this), 1);
          }
        };

        main.specialTargets.push(newTarget);
      } else if (type == "explosive") {
        const newTarget = {
          x: x ? x : Math.trunc(Math.random() * canvas.width),
          y: y ? y : Math.trunc(Math.random() * canvas.height),
          size: 16,
          color: "red",
          stroke: "maroon",
          strokeSize: 3,
          confetti: minExplosiveConfetti,
          type: type,
          collect: function() {
            for (let i = 0; i < this.confetti * explosiveConfettiMult; i++) {
              main.particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * 140 - 70),
                yVelocity: Math.trunc(Math.random() * 140 - 70),
                friction: 0,
                lifespan: Math.trunc((.4 + Math.random() * .4) * FPS * explosiveLifetimeMult),
                color: "orange",
                isCollector: true,
                movementIsCrucial: true,
                onDeath: () => { points += pointsMult },
              });
            }
            
            main.specialTargets.splice(main.specialTargets.indexOf(this), 1);
          }
        };

        main.specialTargets.push(newTarget);
      } else if (type == "gold") {
        const newTarget = {
          x: x ? x : Math.trunc(Math.random() * canvas.width),
          y: y ? y : Math.trunc(Math.random() * canvas.height),
          size: Math.random() * goldTargetSize / 2 + goldTargetSize,
          color: "gold",
          stroke: "#E0B600",
          strokeSize: 3,
          confetti: 0,
          type: type,
          collect: function(parentArray = main.specialTargets) {
            this.size -= goldTargetDecay;
    
            const maxVelo = 25 + 4 * goldTargetDrop;
            for (let i = 0; i < goldTargetDrop; i++) {
              main.particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * maxVelo - maxVelo / 2),
                yVelocity: Math.trunc(Math.random() * maxVelo - maxVelo / 2),
                friction: 1,
                lifespan: Math.trunc((normalParticleTime + Math.random() * normalParticleTime / 2) * FPS),
                color: this.color,
                onDeath: () => { points += 10 * pointsMult; },
              });
            }

            if (this.size < goldTargetMinSize) {
              parentArray.splice(parentArray.indexOf(this), 1);
            }
          }
        };

        main.specialTargets.push(newTarget);
      } else if (type == "rain") {
        const newTarget = {
          x: Math.trunc(Math.random() * canvas.width),
          y: Math.trunc(Math.random() * canvas.height),
          size: 18,
          color: "#6495ED84",
          confetti: 50,
          type: type,
          collect: function() {
            // start rain
            if (!rainDuration) {
              rainIntensity = Math.random() * .5 + .5;
              rainSpeed = Math.random() * 10 + 20 * rainIntensity;
              rainAngle = Math.random() * 4 - 2;
              rainAmount = Math.ceil(Math.random() * 4 * rainIntensity);
            }
            rainDuration = 3600;

            // water plots
            for (let i = 0; i < gardenPlots.length; i++) {
              const plot = gardenPlots[i];
              plot.wetness = Math.trunc(Math.random() * wetRandRange + minWetness);
            }
            world.areas["farmers market"].items.find(e => e.id == "water plot").refresh();

            // begin target-collection splash effect
            for (let i = 0; i < this.confetti; i++) {
              world.areas["garden"].particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * 40 - 20),
                yVelocity: Math.trunc(Math.random() * 40 - 20),
                friction: 1,
                lifespan: Math.trunc((.1 + Math.random() / 4) * FPS),
                color: this.color,
                isCosmetic: true,
              });
            }

            garden.specialTargets.splice(garden.specialTargets.indexOf(this), 1);
          }
        };

        garden.specialTargets.push(newTarget);
      }
    }

    const drawTargets = targetArray => {
      for (let i = 0; i < targetArray.length; i++) {
        const target = targetArray[i];

        if (target.stroke) {
          ctx.strokeStyle = target.stroke;
          ctx.lineWidth = target.strokeSize || 1;
          ctx.strokeRect(target.x - (target.size / 2), target.y - (target.size / 2), target.size, target.size);
        }

        ctx.fillStyle = target.color;
        ctx.fillRect(target.x - (target.size / 2), target.y - (target.size / 2), target.size, target.size);
      }
    }

    const collectTarget = target => {
      const main = world.areas["main"];
      const garden = world.areas["garden"];
      target.collect();

      if (target.type == "gold" && goldAutoCollect) {
          main.autoTargets.push(
            ...main.specialTargets.splice(main.specialTargets.indexOf(target), 1)
          );

      } else if (target.type == "rain") {        
        garden.specialTargets.splice(garden.specialTargets.indexOf(target), 1);
      }
    }

    const doAutoCollection = () => {
      for (let i = 0; i < Object.keys(world.areas).length; i++) {
        const targetArray = world.areas[Object.keys(world.areas)[i]].autoTargets;
        
        if (!targetArray) continue;

        for (let j = 0; j < targetArray.length; j++) {
          targetArray[j].collect(targetArray);
        }
      }
    }
    //#endregion

    //#region utility 
    function addVectors(v1, v2) {
      const p1 = v1.toPoint();
      const p2 = v2.toPoint();
      const resultPoint = new Point(p1.x + p2.x, p1.y + p2.y);
  
      return Vector.fromPoints(new Point(0, 0), resultPoint);
    }
    function subtractVectors(v1, v2) {
      const p1 = v1.toPoint();
      const p2 = v2.toPoint();
      const resultPoint = new Point(p1.x - p2.x, p1.y - p2.y);
      return Vector.fromPoints(new Point(0, 0), resultPoint);
    }
        
    const randomTargetColor = strength => {
      const h = Math.floor(Math.random() * 256);
      const s = Math.trunc(strength * 100);
      const l = 50;
      const a = Math.max(strength.toFixed(2), .3);
      return `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    
    const randomSign = () => {
      return Math.random() < 0.5 ? -1 : 1;
    }
    //#endregion

    const showTooltip = item => {
      const tooltip = document.getElementById("tooltip");

      tooltip.innerText = item.tooltip;
      tooltip.style.transitionDelay = "200ms";
      tooltip.style.opacity = 1
    }
    const hideTooltip = () => {
      const tooltip = document.getElementById("tooltip");
      tooltip.style.transitionDelay = "0ms";
      tooltip.style.opacity = 0;
    }
    
    const drawText = () => {
      // general styles
      ctx.fillStyle = "black";
      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(255, 255, 255, .95)";

      if (showVersionCode) {
        ctx.font = "18px serif";
        ctx.textAlign = "right";
        ctx.fillText(version, canvas.width - 20, canvas.height - 20);
      }

      if (showCurrency) {
        ctx.font = "22px arial";
        ctx.textAlign = "left";
        
        const ptText = `Points: ${points}`;
        ctx.strokeText(ptText, 20, 30);
        ctx.fillText(ptText, 20, 30);

        if (world.areas["garden"].unlocked) {
          const leafText = `Leaves: ${leaves}`;
          ctx.strokeText(leafText, 20, 54);
          ctx.fillText(leafText, 20, 54);
        }
      }
    }

    const drawDoors = () => {
      ctx.lineWidth = 3;
      ctx.strokeStyle = "white";
      ctx.font = "18px serif";

      const theseDoors = world.areas[scene].doors.filter(door => world.areas[door.destination].unlocked);
      for (let i = 0; i < theseDoors.length; i++) {
        const door = theseDoors[i];

        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        
        if (door.side == "right") {
          const doorPosition = door.position ? canvas.height * door.position : canvas.height / 2;

          if (showDoorLabel) {
            ctx.textAlign = "right";
            ctx.strokeText(`${door.destination} `, canvas.width - 20, doorPosition);
            ctx.fillText(`${door.destination} `, canvas.width - 20, doorPosition);
          }

          if (showDoorway) {
            ctx.fillStyle = doorColor;
            ctx.fillRect(canvas.width, doorPosition - doorSize, -5, doorSize * 2);
          }
        } else if (door.side == "left") {
          const doorPosition = door.position ? canvas.height * door.position : canvas.height / 2;

          if (showDoorLabel) {
            ctx.textAlign = "left";
            ctx.strokeText(` ${door.destination}`, 20, doorPosition);
            ctx.fillText(` ${door.destination}`, 20, doorPosition);
          }

          if (showDoorway) {
            ctx.fillStyle = doorColor;
            ctx.fillRect(0, doorPosition - doorSize, 5, doorSize * 2);
          }
        }
        if (door.side == "top") {
          const doorPosition = door.position ? canvas.width * door.position : canvas.width / 2;

          if (showDoorLabel) {
            ctx.strokeText("", doorPosition, 20);
            ctx.fillText("", doorPosition, 20);
            ctx.strokeText(door.destination, doorPosition, 35);
            ctx.fillText(door.destination, doorPosition, 35);
          }

          if (showDoorway) {
            ctx.fillStyle = doorColor;
            ctx.fillRect(doorPosition - doorSize, 0, doorSize * 2, 5);
          }
        } else if (door.side == "bottom") {
          const doorPosition = (door.position ? canvas.width * door.position : canvas.width / 2);

          if (showDoorLabel) {
            ctx.textAlign = "bottom";
            ctx.strokeText("", doorPosition, canvas.height - 20);
            ctx.fillText("", doorPosition, canvas.height - 20);
            ctx.strokeText(door.destination, doorPosition, canvas.height - 35);
            ctx.fillText(door.destination, doorPosition, canvas.height - 35);
          }

          if (showDoorway) {
            ctx.fillStyle = doorColor;
            ctx.fillRect(doorPosition - doorSize, canvas.height, doorSize * 2,  -5);
          }
        }
      }
    }
    const randomEvents = deltaT => {
      const main = world.areas["main"];
      // main targets
      if (Math.random() < targetChance * deltaT && main.targets.length < maxTargets) spawnTarget();
      if (darkTargetUnlocked && Math.random() < (strictTargetAmountLimit ? darkTargetChance * deltaT : darkTargetChance * deltaT / 2) * specialTargetRateMult && main.specialTargets.length < maxSpecialTargets && main.targets.length < Math.max(safeMaxTargets, maxTargets + 10)) spawnTarget(null, null, "dark");
      if (explosiveTargetUnlocked && Math.random() < explosiveTargetChance * deltaT * specialTargetRateMult && main.specialTargets.length < maxSpecialTargets) spawnTarget(null, null, "explosive");
      if (goldTargetUnlocked && Math.random() < goldTargetChance * deltaT * specialTargetRateMult && main.specialTargets.length < maxSpecialTargets) spawnTarget(null, null, "gold");

      // garden targets
      if (rainUnlocked && Math.random() < rainTargetChance * deltaT && world.areas["garden"].specialTargets.length < maxGardenSpecialTargets) spawnTarget(null, null, "rain");
    }

    const spawnRain = deltaT => {
      for (let i = 0; i < rainAmount; i++) {
        world.areas["garden"].particles.push({
          x: Math.random() * (canvas.width + canvas.width * .1) - canvas.width * .05,
          y: 0,
          xVelocity: rainAngle,
          yVelocity: rainSpeed,
          friction: 0,
          lifespan: (Math.random() * (canvas.height * 1.25 / rainSpeed / FPS)) * FPS,
          color: "#6495ED84",
          ignoreWalls: true,
          type: "rain",
          onDeath: function () { 
            world.areas["garden"].particles.push({
              x: this.x,
              y: this.y,
              xVelocity: 0,
              yVelocity: 0,
              friction: 0,
              lifespan: .4 * FPS,
              maxLifespan: .4 * FPS,
              hue: 230,
              saturation: 55,
              lightness: 40,
              startingTransparency: .2,
              size: 10,
              fadeToTransparent: true,
              ignoreWalls: true,
              type: "rain",
            })
          },
        });
      }

      rainDuration -= 1;
    }

    const update = deltaT => {
      movePlayer(deltaT);
      moveParticles(deltaT);
      randomEvents(deltaT);

      growCrops(deltaT);
      if (!rainDuration) {
        updateGardenWetness();
      } else if (showRain && scene == "garden") {
        spawnRain(deltaT);
      }

      doCollisions(player, world.areas[scene]);

      if (shopFocus) detectPurchase();

      doAutoCollection();
      if (world.areas[scene].items) updateShopPositions(world.areas[scene].items);
    }

    const render = () => {
      const area = world.areas[scene];

      canvas.style.backgroundColor = area.color;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (scene == "garden") drawGardenPlots();
      
      if (area.items) drawShopItems(area.items);
      if (area.targets && showNormalTargets) drawTargets(area.targets);
      if (area.specialTargets && showSpecialTargets) drawTargets(area.specialTargets);
      if (area.autoTargets && showSpecialTargets) drawTargets(area.autoTargets);

      drawParticles();
      drawText();
      if (showDoorLabel || showDoorway) drawDoors();
      drawPlayer();

      if (shopFocus) {
        drawPurchaseButton();
      }
    }

    //#region garden
    let gardenPlots = [];

    const harvestCrop = crop => {
      for (let i = 0; i < crop.confetti + cropHarvestBonus; i++) {
        world.areas["garden"].particles.push({
          x: crop.x,
          y: crop.y,
          xVelocity: Math.trunc(Math.random() * 14 - 7),
          yVelocity: Math.trunc(Math.random() * 14 - 7),
          friction: 1,
          lifespan: Math.trunc((1 + Math.random() * .5) * FPS),
          color: `hsl(120, 80%, 40%)`,
          onDeath: () => leaves += 1,
        });
      }

      crop.growth = 0;
    }

    const growCrops = deltaT => {
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];

        for (let j = 0; j < plot.strips.length; j++) {
          const strip = plot.strips[j];

          for (let k = 0; k < strip.length; k++) {
            const crop = strip[k];

            if (crop.growth < 1 && Math.random() < cropGrowthChance * deltaT) crop.growth = Math.min(crop.growth + .1 + (plot.fertility ? .15 : 0) + (plot.wetness ? .1 : 0), 1);
          }
        }
      }
    }

    const updateGardenWetness = () => {
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];

        // if not zero, -1, then, if zero, update shop item
        if (plot.wetness && !--plot.wetness) farmersMarketItems.find(e => e.id == "water plot").refresh();
      }
    }

    const gardenPadding = 100;
    const drawGardenPlots = () => {
      const plotLength = 250;
      const plotHeight = 200;

      const plotsPerGridRow = Math.min(gardenPlots.length, Math.floor((canvas.width - gardenPadding * 2) / plotLength));
      const gridRows = Math.ceil(gardenPlots.length / plotsPerGridRow);
      const plotGapX = (canvas.width - gardenPadding * 2 - plotsPerGridRow * plotLength) / Math.max(1, plotsPerGridRow - 1);
      const plotGapY = (canvas.height - gardenPadding * 2 - gridRows * plotHeight) / Math.max(1, gridRows - 1);

      const stripsPerPlot = 5;
      const plotPadding = 10;
      const stripLength = plotLength - plotPadding * 2;
      const stripHeight = (plotHeight - plotPadding * 2 - plotPadding * (stripsPerPlot - 1)) / stripsPerPlot;

      const cropsPerStrip = 5;
      const cropGap = stripLength / (cropsPerStrip + 1);

      // draw plot
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];
        const plotColor = `hsl(36, 39%, ${60 - (plot.fertility ? 15 : 0) - (plot.wetness ? 15 : 0)}%)`;
        const gardenGridX = i % plotsPerGridRow;
        const gardenGridY = Math.floor(i / plotsPerGridRow);

        plot.x = gardenPadding + plotLength * gardenGridX + plotGapX * gardenGridX;
        plot.y = gardenPadding + plotHeight * gardenGridY + plotGapY * gardenGridY;

        ctx.fillStyle = plotColor;
        ctx.fillRect(plot.x, plot.y, plotLength, plotHeight);

        // draw strips
        for (let j = 0; j < plot.strips.length; j++) {
          const strip = plot.strips[j];

          const stripColor = `hsl(36, 39%, ${50 - (plot.fertility ? 15 : 0) - (plot.wetness ? 15 : 0)}%)`;

          const stripX = plot.x + plotPadding;
          const stripY = plot.y + plotPadding + j * stripHeight + j * plotPadding;

          ctx.fillStyle = stripColor;
          ctx.fillRect(stripX, stripY, stripLength, stripHeight);

          // draw crops
          for (let k = 0; k < strip.length; k++) {
            const crop = strip[k];

            crop.x = stripX + cropGap * (k + 1);
            crop.y = stripY + stripHeight / 2;
            const cropColor = crop.growth == 1 ? "hsl(120, 100%, 33%)" : `hsl(120, ${(crop.growth * .75 + .25) * 100}%, ${(1 - (crop.growth * .4 + .2)) * 100}%)`;
            const sizeMod = crop.growth * .8 + .2;

            ctx.fillStyle = cropColor;
            ctx.fillRect(crop.x - maxCropSize * sizeMod / 2, crop.y - maxCropSize * sizeMod / 2, maxCropSize * sizeMod, maxCropSize * sizeMod);
          }
        }
      }
    }

    //#endregion

    //#region shop
    const purchaseIsValid = shopItem => {
      return (shopItem.price ? shopItem.price <= points : true) && (shopItem.leafPrice ? shopItem.leafPrice <= leaves : true) && (shopItem.maxLevel ? shopItem.level < shopItem.maxLevel : true);
    }

    const detectPurchase = () => {
      if (!controller.interact || player.movement.magnitude) return;
      const area = world.areas[scene];

      if (scene == "settings") {
        shopFocus.onPurchase();
      } else {
        shopFocus.level += 1;
        points -= shopFocus.price;
        if (shopFocus.leafPrice) leaves -= shopFocus.leafPrice;
        shopFocus.onPurchase();

        if (showCosmeticParticles) {
          const drops = Math.floor((shopFocus.level == shopFocus.maxLevel ? Math.min(25 * shopFocus.level, 150) : Math.min(7 * shopFocus.level, 100)) / (showCosmeticParticles == 1 ? 3 : 1));
          const maxVelo = drops / 8 + 10;
          for (let i = 0; i < drops; i++) {
            area.particles.push({
              x: shopFocus.x,
              y: shopFocus.y,
              xVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
              yVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
              friction: 1,
              lifespan: Math.trunc((.25 + Math.random() * .25) * FPS),
              color: shopFocus.level == shopFocus.maxLevel ? "hsl(47, 100%, 50%)" : "rgb(0, 200, 0)",
              isCosmetic: true,
            });
          }
        }
      }

      updateShopPositions(area.items);
      controller.interact = false;
    }

    const drawPurchaseButton = () => {
      ctx.font = "40px sans-serif";
      ctx.textAlign = "center";
      if (ctx.fillStyle != "lime") ctx.fillStyle = "lime";
      if (ctx.lineWidth != 3) ctx.lineWidth = 3;
      if (ctx.strokeStyle != "black") ctx.strokeStyle = "black";
      ctx.strokeText(interactionMessage, player.x, player.y - 50);
      ctx.fillText(interactionMessage, player.x, player.y - 50);
    }

    const updateShopPositions = itemArray => {
      itemArray = itemArray.filter(item => item.unlocked);
      const shopItemsPerRow = 5;
      const shopRows = 4;
      const shopPadding = 3 * itemButtonSize;
      const rowGap = (canvas.height - shopPadding * 2 - shopRows * itemButtonSize) / (shopRows - 1);
      const colGap = (canvas.width - shopPadding * 2 - shopItemsPerRow * itemButtonSize) / (shopItemsPerRow - 1);

      for (let i = 0; i < itemArray.length; i++) {
        const item = itemArray[i];

        const row = Math.floor(i / shopItemsPerRow) + 1;
        const col = i % shopItemsPerRow + 1;

        item.x = shopPadding + (col - 1) * itemButtonSize + (col - 1) * colGap + itemButtonSize / 2;
        item.y = shopPadding + (row - 1) * itemButtonSize + (row - 1) * rowGap + itemButtonSize / 2;
      }
    }

    const drawShopItems = itemArray => {
      itemArray = itemArray.filter(item => item.unlocked);

      for (let i = 0; i < itemArray.length; i++) {
        const item = itemArray[i]

        // draw button
        if (item.color) {
          ctx.fillStyle = item.color;
        } else if (item.level === item.maxLevel) {
          ctx.fillStyle = "hsl(47, 100%, 50%)";
        } else if (item.price <= points && (item.leafPrice ? item.leafPrice <= leaves : true)) {
          ctx.fillStyle = "rgb(0, 200, 0)";
        } else {
          ctx.fillStyle = "rgb(200, 0, 0)";
        }
        ctx.fillRect(item.x - itemButtonSize / 2, item.y - itemButtonSize / 2, itemButtonSize, itemButtonSize);
        if (item.stroke) {
          ctx.strokeStyle = item.stroke;
          ctx.strokeRect(item.x - itemButtonSize / 2, item.y - itemButtonSize / 2, itemButtonSize, itemButtonSize);
        }

        // draw "new!" badge
        if (scene != "settings" && item.level == 0 && !item.purchasedBefore) {
          ctx.font = "bold 20px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = purchaseIsValid(item) ? "rgb(200, 0, 0)" : "rgb(200, 0, 0)";
          ctx.fillText("new!", item.x, item.y - itemButtonSize / 1.5);
        }

        // draw item title
        ctx.font = "20px serif";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        const titleText = item.title;
        ctx.fillText(titleText, item.x, item.y + itemButtonSize);

        if (!(item.level < item.maxLevel)) continue;

        // draw pricing
        const tempStrings = [];
        if (item.price) tempStrings.push(`${item.price} points`);
        if (item.leafPrice) tempStrings.push(`${item.leafPrice} leaves`);
        ctx.fillText(tempStrings.join(", "), item.x, item.y + itemButtonSize + 20);
      }
    }
    //#endregion

    const gameLoop = timestamp => {
      if (!lastFrameTime) lastFrameTime = timestamp;
      const deltaT = FPS / (1000 / ((timestamp - lastFrameTime) || 1)); // seconds
      lastFrameTime = timestamp;

      update(deltaT);
      render();

      requestAnimationFrame(gameLoop);
    }

    let lastFrameTime = null;

    // start the game with a few targets
    for (let i = 0; i < 5; i++) spawnTarget();

    //#region scale the canvas to the screen
    function scaleCanvas() {      
      const scale = {
        x: userHasTouchScreen ? window.outerWidth / canvas.width : window.innerWidth / canvas.width,
        y: userHasTouchScreen ? window.outerHeight / canvas.height : window.innerHeight / canvas.height
      }

      const fitCanvasToScreenHeight = scale.x > scale.y;

      // Apply scaling
      if (fitCanvasToScreenHeight) {
        canvas.style.transformOrigin = "top";
        canvas.style.transform = `scale(${scale.y})`;
      } else {
        canvas.style.transformOrigin = "top";
        canvas.style.transform = `scale(${scale.x})`;
      }

      const tooltip = document.getElementById("tooltip");
      
      tooltip.style.maxWidth = canvas.getBoundingClientRect().width * .75;
      tooltip.style.left = canvas.getBoundingClientRect().width * .75;
    }
    addEventListener("resize", ()=>{
      userHasTouchScreen = navigator.maxTouchPoints > 0 && window.matchMedia("(pointer: coarse)").matches;

      if (userHasTouchScreen)  {
        unlockItems(settingsItems, "allow touch controls");
        if (useTouchController) unlockItems(settingsItems, "controller size", "use joystick");
      } else {
        lockItems(settingsItems, "controller size", "allow touch controls", "use joystick");
      }
      
      scaleCanvas();
      updateTouchControllers(touchControllerSize());
    });
    //#endregion
    
    //#region initialization
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      points = 10000000000;
      leaves = 10000000;
    }
    scaleCanvas();
    setupPlayerControls();
    requestAnimationFrame(gameLoop);

    // warn against using portrait screen orientation
    if (!screen.orientation.type.includes("landscape")) alert("This game is probably better in landscape orientation.");
    screen.orientation.addEventListener("change", item => {
      if (!screen.orientation.type.includes("landscape"))
        alert("This game is probably better in landscape orientation.");
    });
    //#endregion
  </script>
</body>

</html>
