<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas</title>
  <style>
    html {
      height: 100%;
      background-color: linen;
      touch-action: none;
      overflow: hidden;
    }

    body {
      margin: 0;
      align-items: center;
      justify-content: center;
      display: grid;
      overflow: hidden;
    }

    canvas {
      background-color: #ffffff;
    }

    #touch-controller {
      display: none;
      position: absolute;
      grid-template: repeat(3, 1fr) / repeat(3, 1fr);
      user-select: none;
      z-index: 1;

      & > * {
        background-color: #00000029;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 3em;

        &:active {
          background-color: transparent;
        }
      }

      & #up {
        grid-area: 1 / 2;
      }

      & #left {
        grid-area: 2 / 1;
      }

      & #adjust-controller {
        grid-area: 2 / 2;
      }

      & #right {
        grid-area: 2 / 3;
      }

      & #down {
        grid-area: 3 / 2;
      }
    }
  </style>
</head>

<body>
  <div id="main">
    <div id="touch-controller">
      <div id="up">&blacktriangle;</div>
      <div id="left">&blacktriangleleft;</div>
      <div id="adjust-controller">&there4;</div>
      <div id="right">&blacktriangleright;</div>
      <div id="down">&blacktriangledown;</div>
    </div>
    <canvas id="canvas" width="1600" height="900"></canvas>
  </div>

  <script defer>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const FPS = 60;
    const controller = {
      up: false,
      left: false,
      right: false,
      down: false,
      interact: false,
    }
    const version = "v0.4.1";
    const userHasTouchScreen = navigator.maxTouchPoints > 0;

    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 10,
      xVelocity: 0,
      yVelocity: 0,
      acceleration: 2,
      friction: 2,
      maxVelocity: 14,
      color: "rgb(255, 0, 0, 1)",
    }

    class Area {
      constructor(doorsArray, particlesArray, targetsArray, itemsArray, backgroundColor, areaIsUnlocked) {
        this.doors = doorsArray;
        this.particles = particlesArray;
        this.targets = targetsArray;
        this.items = itemsArray;
        this.color = backgroundColor;
        this.unlocked = areaIsUnlocked;
      }
    }
    class Door {
      constructor(whichSide, destination, doorPosition) {
        this.side = whichSide;
        this.destination = destination;
        this.position = doorPosition;
      }
    }

    let scene = "main";

    // settings
    let doorSize = 70;
    let showDoorLabel = true;
    let showDoorway = true;
    let showVersionCode = true;
    let showCurrency = true;
    let showNormalTargets = true;
    let showSpecialTargets = true;
    let showParticles = true;
    let strictTargetAmountLimit = false;
    let useTouchController = true;
    let touchControllerSize = ()=>{return Math.min(window.innerWidth, window.innerHeight) / 2};

    const doorColor = "#00000043";

    let shopFocus;
    let interactionMessage = userHasTouchScreen ? "tap" : "E";
    const itemButtonSize = 50;
    const minimumLabelWidth = 200;

    let points = 100000000;
    let pointsMult = 1; // base multiplier appllied when gaining points
    let seeds = 100000000;
    let particleBase = 1; // points from targets
    const particleSize = 8; // visible size of most particles

    let normalParticleTime = 1; // amount of time before a basic particle disappears
    let breadthSizeBonus = 10; // increase target breadth effectiveness on average
    let minimumTargetSize = 30;
    let breadthBonus = 5; // points from target breadth
    let potencyBonus = 10; // points from target potency
    let minimumPotency = 0; // minimum potency (1=100%)
    let maxNormalPotency = .3; // maximum potency (1=100%)
    let superPotentChance = .05; // chance for 100% potency (1=100%)
    let superPotentValue = 3 // amount of bonus particles for super potency

    let maxTargets = 10; // (prevents lag and balances gameplay)
    let safeMaxTargets = 200; // (prevents lag and balances gameplay)
    let targetChance = .01; // chance for a new target to appear each frame (1=100%)
    let maxSpecialTargets = 1; // (balances gameplay)
    let specialTargetCount = 0; // amount of special targets currently in play
    let specialTargetRateMult = 1; // increases the rate of all special target appearances
    //
    let darkTargetUnlocked = false; // dark target can spawn
    let darkTargetChance = .0005; // chance for a new dark target to appear each frame (1=100%)
    let darkTargetConfettiMult = 1; // amount of particles from dark targets
    //
    let explosiveTargetUnlocked = false; // explosive target can spawn
    let explosiveTargetChance = .0005; // chance for a new dark target to appear each frame (1=100%)
    let explosiveLifetimeMult = 1; // increase the amount of time that the explosive particles last for
    let minExplosiveConfetti = 30; // minimum amount of particles that spawn from an explosive target
    let explosiveConfettiMult = 1; // increase the amount of particles that spawn from an explosive target
    //
    let goldTargetUnlocked = false; // gold target can spawn
    let goldTargetChance = .0005; // chance for a new gold target to appear each frame (1=100%)
    let goldTargetDecay = 1; // size reduction per frame of the gold target
    let goldTargetSize = 45; // size reduction per frame of the gold target
    const goldTargetMinSize = 25; // minimum size before a gold target disappears
    let goldTargetDrop = 1; // gold target shoots 2 particles per frame instead of 1
    let goldAutoCollect = false; // gold targets auto collect after being collected once

    const maxGardenPlots = 15; // the maximum allowed number of garden plots to be displayed in the garden area
    let cropGrowthChance = .0005; // chance for garden crops to increase in their 'growth' value by some amount
    const maxCropSize = 28; // maximum physical size for crop display and collision
    let cropHarvestBonus = 0; // multiplies the amount of seeds harvested from garden crops
    let gardenStrips = 0; // sum count of garden strips across all plots
    let rabbitSpeed = 15; // max rabbit speed
    let minWetness = 7000; // minimum amount of frames before garden plot has wetness set to "false"
    let wetRandRange = 4000; // the max amount of frames after the minWetness for which a garden plot may remain wet
    let fertilizerAmount = 200; // number of crop harvests before a plot goes infertile again
    const maxGardenSpecialTargets = 1;
    //
    let rainUnlocked = false; // whether or not rain targets are allowed to spawn
    let rainTargetChance = .00005; // .00005 = 1/20000 frames / 3600 frames = ~5.5 minutes
    let rainDuration = 0; // duration of the rain event
    let showRain = true; // whether or not rain renders
    let rainSpeed = 35; // visible speed of the rain particles
    let rainAngle = 0; // x velocity for the rain particles
    let rainAmount = 3;  // amount of rain particles to be spawned each frame during rain
    let rainIntensity = 1; // limiting value that multiplies against other rain values

    let turtleSpeed = 6;

    const unlockItems = (itemList, ...itemIDs) => {
      for (let i = 0; i < itemIDs.length; i++) {
        const item = itemList.find(item => item.id == itemIDs[i]);
        item.unlocked = true;
      }
      updateShopPositions(itemList)
    }
    const lockItems = (itemList, ...itemIDs) => {
      for (let i = 0; i < itemIDs.length; i++) {
        const item = itemList.find(item => item.id == itemIDs[i]);
        item.unlocked = false;
        item.x = null;
        item.y = null;
      }
    }

    let shopItems = [
      // basic upgrades
      {
        id: "drop per target",
        title: "+1 Drop Per Target",
        unlocked: true,
        level: 0,
        maxLevel: 9,
        price: 20,
        x: undefined,
        y: undefined,
        detail: particleBase,
        onPurchase: function () {
          this.price += 30 * this.level;
          particleBase += 1;
          this.detail = particleBase;

          if (this.level == 1) {
            unlockItems(shopItems, "max targets");
          }

          if (this.level + shopItems.find(item => item.id == "max targets").level == 6) {
            unlockItems(shopItems, "double target spawn", "turtle");
          }

          if (this.level == this.maxLevel) {
            unlockItems(shopItems, "double points");

            this.detail = null;
            this.title = `+${particleBase} Drops Per Target`;
          }
        }
      },
      {
        id: "max targets",
        title: "+10 Max Targets",
        unlocked: false,
        level: 0,
        maxLevel: 29,
        price: 30,
        x: undefined,
        y: undefined,
        detail: maxTargets,
        onPurchase: function () {
          if (this.level == 1) {
            unlockItems(shopItems, "max potency", "max target width", "unlock garden");
          }
          this.price = Math.round(30 + 30 * this.level ** 1.6);
          maxTargets += 10;
          this.detail = maxTargets;

          if (this.level + shopItems.find(item => item.id == "drop per target").level == 6) {
            unlockItems(shopItems, "double target spawn", "turtle");
          }

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${maxTargets} Max Targets`;
          }
        }
      },
      {
        id: "max potency",
        title: "+5% Max Potency",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 100,
        x: undefined,
        y: undefined,
        detail: `${Math.round(maxNormalPotency * 100)}%`,
        onPurchase: function () {
          if (this.level == 1) {
            unlockItems(shopItems, "super potent chance")
          }
          this.price = 100 + Math.round(50 * this.level ** 2);
          maxNormalPotency += .05;
          this.detail = `${Math.round(maxNormalPotency * 100)}%`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${Math.round(maxNormalPotency * 100)}% Max Potency`;
          }
        }
      },
      {
        id: "super potent chance",
        title: "+1% Super Potent Chance",
        unlocked: false,
        level: 0,
        maxLevel: 25,
        price: 50,
        x: undefined,
        y: undefined,
        detail: `${Math.round(superPotentChance * 100)}%`,
        onPurchase: function () {
          superPotentChance += .01;
          this.price += 50;
          this.detail = `${Math.round(superPotentChance * 100)}%`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${Math.round(superPotentChance * 100)}% Super Potent Chance`;
          }
        }
      },
      {
        id: "max target width",
        title: "+2 Max Target Width",
        unlocked: false,
        level: 0,
        maxLevel: 40,
        price: 25,
        x: undefined,
        y: undefined,
        detail: breadthSizeBonus,
        onPurchase: function () {
          this.price = 25 + 15 * this.level;
          breadthSizeBonus += 2;
          this.detail = breadthSizeBonus;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `+${breadthSizeBonus} Max Target Width`;
          }
        }
      },

      // intermediate 
      {
        id: "double target spawn",
        title: "x2 Target Spawn Rate",
        unlocked: false,
        level: 0,
        maxLevel: 6,
        price: 100,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          if (this.level == 1) {
            unlockItems(shopItems, "unlock explosive target")
          }

          this.price *= 5;
          targetChance *= 2;
          this.detail = `x${2 ** this.level}`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `x${2 ** this.level} Target Spawn Rate`;
          }
        }
      },

      // explosive
      {
        id: "unlock explosive target",
        title: "Unlock Explosive Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 200,
        x: undefined,
        y: undefined,
        detail: null,
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          explosiveTargetUnlocked = true;
          
          spawnTarget(null, null, "explosive");
          unlockItems(shopItems, "more explosive targets", "double explosive target drops", "unlock dark target", "max special drops", "double special target rate");

          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more explosive targets",
        title: "20% More Explosive Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 300,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          explosiveTargetChance *= 1.2;
          this.price = Math.round(this.price * 1.2);

          if (this.level == this.maxLevel) {
            this.title = "More Explosive Targets";
          }
        }
      },
      {
        id: "double explosive target drops",
        title: "x2 Explosive Target Drops",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 500,
        x: undefined,
        y: undefined,
        detail: null,
        unlocked: false,
        onPurchase: function () {
          explosiveConfettiMult *= 2;
          this.price *= 5;

          if (this.level == this.maxLevel) {
            this.title = `x${2 ** this.maxLevel} Explosive Target Drops`;
            unlockItems(shopItems, "double explosive time");
          }
        }
      },
      {
        id: "double explosive time",
        title: "Double Explosive Time",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 100000,
        seedPrice: 10000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          explosiveLifetimeMult *= 2;
        }
      },

      // dark
      {
        id: "unlock dark target",
        title: "Unlock Dark Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 500,
        x: undefined,
        y: undefined,
        detail: null,
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          darkTargetUnlocked = true;
          spawnTarget(null, null, "dark");
          unlockItems(shopItems, "more dark targets", "double dark target drops", "unlock gold target");
          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more dark targets",
        title: "20% More Dark Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 400,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          darkTargetChance *= 1.2;

          if (this.level == this.maxLevel) {
            this.title = "More Dark Targets";
          }
        }
      },
      {
        id: "double dark target drops",
        title: "2x Dark Target Drops",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 1500,
        x: undefined,
        y: undefined,
        detail: `x${darkTargetConfettiMult}`,
        unlocked: false,
        onPurchase: function () {
          darkTargetConfettiMult *= 2;
          this.price *= 2;
          this.detail = `x${darkTargetConfettiMult}`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `x${darkTargetConfettiMult} Dark Target Drops`;
          }
        }
      },

      // gold
      {
        id: "unlock gold target",
        title: "Unlock Gold Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 1000,
        x: undefined,
        y: undefined,
        detail: null,
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          goldTargetUnlocked = true;
          spawnTarget(null, null, "gold");
          unlockItems(shopItems, "more gold targets", "double gold target drop", "easy collect gold");
          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more gold targets",
        title: "20% More Gold Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 500,
        x: undefined,
        y: undefined,
        detail: goldTargetDrop,
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          goldTargetChance *= 1.2;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = "More Gold Targets";
          }
        }
      },
      {
        id: "double gold target drop",
        title: "2x Gold Target Drop",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 5000,
        x: undefined,
        y: undefined,
        detail: goldTargetDrop,
        onPurchase: function () {
          goldTargetDrop *= 2;
          this.price *= 5;
          this.detail = goldTargetDrop;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `x${goldTargetDrop} Gold Target Drops`;
          }
        }
      },
      {
        id: "easy collect gold",
        title: "Easy-Collect Gold",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 10000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          goldAutoCollect = true;
          world.areas["main"].autoTargets = [];
        }
      },

      // other special
      {
        id: "double special target rate",
        title: "x2 Special Target Rate",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 1000,
        x: undefined,
        y: undefined,
        detail: `x${specialTargetRateMult}`,
        onPurchase: function () {
          this.price *= 10;
          specialTargetRateMult *= 2;
          this.detail = `x${specialTargetRateMult}`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `x${specialTargetRateMult} Special Target Rate`;
          }
        }
      },
      {
        id: "max special drops",
        title: "+1 Max Special Targets",
        unlocked: false,
        level: 0,
        maxLevel: 9,
        price: 1000,
        x: undefined,
        y: undefined,
        detail: maxSpecialTargets,
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          maxSpecialTargets += 1;
          this.detail = maxSpecialTargets;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${maxSpecialTargets} Max Special Targets`;
          }
        }
      },

      // advanced
      {
        id: "double points",
        title: "x2 Points",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 300000,
        seedPrice: 1000,
        x: undefined,
        y: undefined,
        detail: `x${pointsMult}`,
        onPurchase: function () {
          this.price += 200000 * this.level;
          this.seedPrice += 3000 * this.level;
          pointsMult *= 2;
          if (this.level < this.maxLevel) {
            this.detail = `x${pointsMult}`;
          } else {
            this.detail = null;
            this.title = `x${pointsMult} Points`;
          }
        }
      },
      {
        id: "turtle",
        title: "+1 Turtle",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 100000,
        seedPrice: 10000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          settingsItems.find(e => e.id == "shuffle buddies").unlocked = true;
          
          world.areas["main"].particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            xVelocity: turtleSpeed * randomSign(),
            yVelocity: turtleSpeed * randomSign(),
            friction: 0,
            lifespan: Infinity,
            color: "green",
            isCollector: true,
            size: 16,
            maxSpeed: turtleSpeed,
          });

          this.price *= 5;
          this.seedPrice *= 3;

          if (this.level == this.maxLevel) {
            this.title = `${this.maxLevel} Turtles`;
          }
        }
      },
      {
        id: "unlock garden",
        title: "Unlock Garden Area",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 250,
        x: undefined,
        y: undefined,
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          world.areas["garden"].unlocked = true;
          world.areas["farmers market"].unlocked = true;
          shopItems.splice(shopItems.indexOf(this), 1);
        }
      }
    ];

    let farmersMarketItems = [
      // plot upgrades
      {
        id: "garden plot",
        title: "+1 Garden Plot",
        unlocked: true,
        level: 0,
        maxLevel: maxGardenPlots,
        price: 0,
        seedPrice: 0,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          gardenPlots.push({
            x: null, y: null,
            wetness: rainDuration > 0 ? Math.trunc(Math.random() * wetRandRange + minWetness) : 0,
            fertility: 0,
            strips: [],
          });

          this.price = Math.round(2500 * this.level ** 1.6);
          this.seedPrice = 100 * this.level;
          const farmersMarketItems = world.areas["farmers market"].items;

          if (this.level == 1) unlockItems(farmersMarketItems, "garden row", "water plot", "enrich plot");

          if (this.level == 5) unlockItems(farmersMarketItems, "sunlamp", "unlock rain");

          if (this.level == this.maxLevel) this.title = `${gardenPlots.length} Garden Plots`;

          // update the water + enrich upgrades
          farmersMarketItems.find(item => item.id == "water plot").refresh();
          farmersMarketItems.find(item => item.id == "enrich plot").refresh();

          // update the rows upgrade
          farmersMarketItems.find(item => item.id == "garden row").maxLevel = gardenPlots.length * 5;
        }
      },
      {
        id: "garden row",
        title: "+1 Garden Row",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 0,
        seedPrice: 0,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          this.price = Math.round(500 * this.level ** 1.5);
          this.seedPrice = 20 * this.level;
          this.detail = ++gardenStrips;

          gardenPlots[Math.floor((gardenStrips - 1) / 5)].strips.push([{
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          },]);

          if (this.level == 1) {
            unlockItems(world.areas["farmers market"].items, "crop harvest", "rabbit");
          }
          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${gardenStrips} Garden Rows`;
          }
        }
      },

      {
        id: "water plot",
        title: "Water 1 Plot",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 1000,
        seedPrice: 10,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          this.purchasedBefore = true;
          for (let i = 0; i < gardenPlots.length; i++) {
            const plot = gardenPlots[i];
            if (plot.wetness < 1) {
              plot.wetness = Math.trunc(Math.random() * wetRandRange + minWetness);
              break;
            };
          }
          this.refresh();
        },
        refresh: function () {
          this.maxLevel = gardenPlots.length;
          this.level = gardenPlots.filter(plot => plot.wetness).length;
          this.price = 1000 + 2000 * this.level;
          this.seedPrice = 10 + 10 * this.level;

          if (this.level == this.maxLevel) {
            this.title = "All Plots Watered";
          } else {
            this.title = "Water 1 Plot";
          }
        },
      },
      {
        id: "enrich plot",
        title: "Enrich 1 Plot",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 3000,
        seedPrice: 20,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          this.purchasedBefore = true;
          for (let i = 0; i < gardenPlots.length; i++) {
            const plot = gardenPlots[i];
            if (!plot.fertility) {
              plot.fertility = fertilizerAmount;
              break;
            }
          }
          this.refresh();
        },
        refresh: function () {
          this.maxLevel = gardenPlots.length;
          this.level = gardenPlots.filter(plot => plot.fertility).length;
          this.price = 3000 + 3000 * this.level;
          this.seedPrice = 20 + 10 * this.level;

          if (this.level == this.maxLevel) {
            this.title = "All Plots Enriched";
          } else {
            this.title = "Enrich 1 Plot";
          }
        },
      },

      // general upgrades
      {
        id: "crop harvest",
        title: "+1 Crop Harvest",
        unlocked: false,
        level: 0,
        maxLevel: 9,
        price: 1000,
        seedPrice: 10,
        x: undefined,
        y: undefined,
        detail: cropHarvestBonus,
        onPurchase: function () {
          cropHarvestBonus += 1;
          this.price = 1000 + 2000 * this.level;
          this.seedPrice *= 2;
          this.detail = cropHarvestBonus;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `+${cropHarvestBonus} Crop Harvest`;
          }
        }
      },
      {
        id: "sunlamp",
        title: "Install Sunlamp",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 200000,
        seedPrice: 2500,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          cropGrowthChance *= 2;
          this.title = "Sunlamp";
        }
      },
      {
        id: "unlock rain",
        title: "Unlock Rain",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 200000,
        seedPrice: 1000,
        x: undefined,
        y: undefined,
        detail: null,
        stroke: "hsl(47, 100%, 50%)",
        onPurchase: function () {
          rainUnlocked = true;
          spawnTarget(null, null, "rain");
          unlockItems(settingsItems, "show rain");
        }
      },
      {
        id: "rabbit",
        title: "+1 Rabbit",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 500,
        seedPrice: 30,
        x: undefined,
        y: undefined,
        detail: cropHarvestBonus,
        onPurchase: function () {
          settingsItems.find(e => e.id == "shuffle buddies").unlocked = true;

          world.areas["garden"].particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            xVelocity: rabbitSpeed * randomSign(),
            yVelocity: rabbitSpeed * randomSign(),
            friction: 0,
            lifespan: Infinity,
            color: "white",
            stroke: "gray",
            isCollector: true,
            size: 16,
            maxSpeed: rabbitSpeed,
          });
          this.price *= 20;
          this.seedPrice *= 10;

          if (this.level == this.maxLevel) {
            this.title = `${this.level} Rabbits`;
          }
        }
      },
    ];

    
    let settingsItems = [
      {
        id: "allow touch controls",
        title: "Touch Controller",
        unlocked: userHasTouchScreen,
        enabled: true,
        x: undefined,
        y: undefined,
        detail: "enabled",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;

          if (this.enabled) {
            unlockItems(settingsItems, "controller size");
          } else {
            lockItems(settingsItems, "controller size");
          }

          // external impact
          document.getElementById("touch-controller").style.display = this.enabled ? "grid" : "none";
          useTouchController = this.enabled;

          // item update
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.detail = this.enabled ? "enabled" : "disabled";
        }
      },
      {
        id: "controller size",
        title: "Controller Size",
        unlocked: userHasTouchScreen,
        level: 4,
        x: undefined,
        y: undefined,
        detail: "auto",
        color: "rgb(0, 40, 200)",
        onPurchase: function () {
          this.level = (this.level + 1) % 5;

          touchControllerSize = [()=>{return 200}, ()=>{return 400}, ()=>{return 600}, ()=>{return Math.min(window.innerWidth, window.innerHeight) / 3}, ()=>{return Math.min(window.innerWidth, window.innerHeight) / 2}][this.level];
          replaceTouchController(touchControllerSize());

          this.color = ["rgb(200, 0, 0)", "orange", "gold", "rgb(0, 200, 0)", "rgb(0, 40, 200)"][this.level];
          this.detail = ["small", "medium", "large", "auto small", "auto"][this.level];
        }
      },
      {
        id: "show version",
        title: "Show Version Code",
        unlocked: true,
        enabled: true,
        x: undefined,
        y: undefined,
        detail: "shown",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          showVersionCode = this.enabled;
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.detail = this.enabled ? "shown" : "hidden";
        }
      },
      {
        id: "show currency",
        title: "Show Currency",
        unlocked: true,
        enabled: true,
        x: undefined,
        y: undefined,
        detail: "shown",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          showCurrency = this.enabled;
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.detail = this.enabled ? "shown" : "hidden";
        }
      },
      {
        id: "show particles",
        title: "Show Drops",
        unlocked: true,
        enabled: true,
        x: undefined,
        y: undefined,
        detail: "shown",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          showParticles = this.enabled;
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.detail = this.enabled ? "shown" : "hidden";
          
          if (this.enabled) {
            unlockItems(settingsItems, "particle time");
          } else {
            lockItems(settingsItems, "particle time");
          }
        }
      },
      {
        id: "particle time",
        title: "Drop Collect Speed",
        unlocked: true,
        level: 1,
        x: undefined,
        y: undefined,
        detail: "normal",
        color: "orange",
        onPurchase: function () {
          this.level = (this.level + 1) % 4;
          normalParticleTime = [2, 1, .25, .1][this.level];
          this.color = ["rgb(200, 0, 0)", "orange", "gold", "rgb(0, 200, 0)"][this.level];
          this.detail = ["slow", "medium", "fast", "really fast"][this.level];
        }
      },
      {
        id: "show targets",
        title: "Show Targets",
        unlocked: true,
        level: 3,
        x: undefined,
        y: undefined,
        detail: "all",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.level = (this.level + 1) % 4;

          showNormalTargets = [false, true, false, true][this.level];
          showSpecialTargets = [false, false, true, true][this.level];

          this.color = ["rgb(200, 0, 0)", "orange", "gold", "rgb(0, 200, 0)"][this.level];
          this.detail = ["none", "only basic targets", "only special targets", "all"][this.level];
        }
      },
      {
        id: "target limit",
        title: "Limit Targets",
        unlocked: true,
        enabled: false,
        x: undefined,
        y: undefined,
        detail: "lax",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          strictTargetAmountLimit = this.enabled;
          this.color = this.enabled ? "rgb(200, 0, 0)" : "rgb(0, 200, 0)";
          this.detail = this.enabled ? "strict" : "lax";
        }
      },
      {
        id: "show doors",
        title: "Show Doorways",
        unlocked: true,
        level: 3,
        x: undefined,
        y: undefined,
        detail: "labels and doorways",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.level = (this.level + 1) % 4;

          if (this.level == 0) {
            showDoorway = false;
            showDoorLabel = false;
          } else if (this.level == 1) {
            showDoorway = true;
            showDoorLabel = false;
          } else if (this.level == 2) {
            showDoorway = false;
            showDoorLabel = true;
          } else if (this.level == 3) {
            showDoorway = true;
            showDoorLabel = true;
          }

          this.color = ["rgb(200, 0, 0)", "orange", "gold", "rgb(0, 200, 0)"][this.level];
          this.detail = ["none", "doorways", "labels", "labels & doorways"][this.level];
        }
      },
      {
        id: "door size",
        title: "Door Size",
        unlocked: true,
        level: 1,
        x: undefined,
        y: undefined,
        detail: "medium",
        color: "gold",
        onPurchase: function () {
          this.level = (this.level + 1) % 3;

          doorSize = [40, 70, 100][this.level];

          this.color = ["rgb(200, 0, 0)", "gold", "rgb(0, 200, 0)"][this.level];
          this.detail = ["small", "medium", "large"][this.level];
        }
      },
      {
        id: "show rain",
        title: "Show Rain",
        unlocked: false,
        enabled: true,
        x: undefined,
        y: undefined,
        detail: "shown",
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          this.enabled = !this.enabled;
          showRain = this.enabled;
          this.color = this.enabled ? "rgb(0, 200, 0)" : "rgb(200, 0, 0)";
          this.detail = this.enabled ? "shown" : "hidden";
        }
      },
      {
        id: "shuffle buddies",
        title: "Shuffle Buddies",
        unlocked: false,
        x: undefined,
        y: undefined,
        color: "rgb(0, 200, 0)",
        onPurchase: function () {
          for (let i = 0; i < Object.keys(world.areas).length; i++) {
            const area = world.areas[Object.keys(world.areas)[i]];
            
            if (!area.particles) continue;
            for (let j = 0; j < area.particles.length; j++) {
              const particle = area.particles[j];

              if (particle.lifespan !== Infinity || !particle.isCollector) continue;
              
              particle.xVelocity = particle.maxSpeed * randomSign();
              particle.yVelocity = particle.maxSpeed * randomSign();

              particle.x = Math.trunc(Math.random() * canvas.width);
              particle.y = Math.trunc(Math.random() * canvas.height);
            } 
          }
        }
      },
    ];
    
    const world = {
      scene: "main",
      areas: {
        "main": new Area([new Door("right", "garden"), new Door("left", "garden"), new Door("bottom", "shop")], [], [], null, "white", true),
        "shop": new Area([new Door("right", "farmers market"), new Door("left", "farmers market"), new Door("top", "main"), new Door("top", "settings", .8)], [], null, shopItems, "rgb(240, 225, 200)", true),
        "garden": new Area([new Door("right", "main"), new Door("left", "main"), new Door("bottom", "farmers market")], [], [], null, "rgb(200, 255, 200)"),
        "farmers market": new Area([new Door("right", "shop"), new Door("left", "shop"), new Door("top", "garden"), new Door("top", "settings", .2)], [], null, farmersMarketItems, "rgb(200, 255, 200)"),
        "settings": new Area([new Door("bottom", "farmers market", .2), new Door("bottom", "shop", .8)], [], null, settingsItems, "white", true),
      },
    }
    world.areas["main"].specialTargets = [];
    world.areas["garden"].specialTargets = [];
    
    //#region collisions
    const doCollisions = (collider, area) => {
      if (area.targets) {
        for (let i = 0; i < area.targets.length; i++) {
          const target = area.targets[i];
          if (rectsDoCollide(collider, target)) collectTarget(target);
        }
      }
      if (area.specialTargets) {
        for (let i = 0; i < area.specialTargets.length; i++) {
          const target = area.specialTargets[i];
          if (rectsDoCollide(collider, target)) collectTarget(target);
        }
      }
      if (area.items) {
        shopFocus = undefined;
        for (let i = 0; i < area.items.length; i++) {
          const item = area.items[i];
          if (purchaseIsValid(item) && rectsDoCollide(collider, { ...item, size: itemButtonSize })) {
            shopFocus = item;
            break;
          }
        }
      }

      // garden collisions (crop targets are organized differently data-wise)
      if (area == world.areas["garden"]) {
        for (let i = 0; i < gardenPlots.length; i++) {
          const plot = gardenPlots[i];
          for (let j = 0; j < plot.strips.length; j++) {
            const strip = plot.strips[j];
            for (let k = 0; k < strip.length; k++) {
              const crop = strip[k];

              if (crop.growth >= 1 && rectsDoCollide(collider, { x: crop.x, y: crop.y, size: maxCropSize })) {
                harvestCrop(crop);
                // if not zero, -1, then, if zero, update shop item
                if (plot.fertility && !--plot.fertility) farmersMarketItems.find(e => e.id == "enrich plot").refresh();
              }
            }
          }
        }
      }
    }

    const rectsDoCollide = (rect1, rect2) => {
      const r1Half = rect1.size / 2;
      const r1 = {
        top: rect1.y - r1Half,
        bottom: +rect1.y + r1Half,
        right: +rect1.x + r1Half,
        left: rect1.x - r1Half,
      }

      const r2Half = rect2.size / 2;
      const r2 = {
        top: rect2.y - r2Half,
        bottom: +rect2.y + r2Half,
        right: +rect2.x + r2Half,
        left: rect2.x - r2Half,
      }

      return (r1.left < r2.right && r1.left > r2.left || r1.right > r2.left && r1.right < r2.right) && (r1.top < r2.bottom && r1.top > r2.top || r1.bottom > r2.top && r1.bottom < r2.bottom);
    }
    //#endregion

    //#region player
    const setupPlayerControls = () => {
      document.body.addEventListener("contextmenu", e => e.preventDefault());

      setupKeyboardControls();

      if (userHasTouchScreen) setupTouchControls();
    }

    const setupKeyboardControls = () => {
      window.addEventListener("keydown", (event) => {
        switch (event.key.toLowerCase()) {
          case "w":
            controller.up = true;
            break;
          case "arrowup":
            controller.up = true;
            break;
          case "a":
            controller.left = true;
            break;
          case "arrowleft":
            controller.left = true;
            break;
          case "d":
            controller.right = true;
            break;
          case "arrowright":
            controller.right = true;
            break;
          case "s":
            controller.down = true;
            break;
          case "arrowdown":
            controller.down = true;
            break;
          case "e":
            controller.interact = true;
            break;
        }
      });

      window.addEventListener("keyup", (event) => {
        switch (event.key.toLowerCase()) {
          case "w":
            controller.up = false;
            break;
          case "arrowup":
            controller.up = false;
            break;
          case "a":
            controller.left = false;
            break;
          case "arrowleft":
            controller.left = false;
            break;
          case "d":
            controller.right = false;
            break;
          case "arrowright":
            controller.right = false;
            break;
          case "s":
            controller.down = false;
            break;
          case "arrowdown":
            controller.down = false;
            break;
          case "e":
            controller.interact = false;
            break;
        }
      });
    }

    const setupTouchControls = () => {
      const touchController = document.getElementById("touch-controller");
      // display
      replaceTouchController(touchControllerSize());
      
      // functionality
      const adjustmentControl = document.getElementById("adjust-controller");
      adjustmentControl.addEventListener("touchmove", e => {
        const touch = e.changedTouches[0]
        const halfController = touchControllerSize() / 2;
        touchController.style.left = `${touch.clientX - halfController}px`;
        touchController.style.top = `${touch.clientY - halfController}px`;
      });
      ["touchend", "touchcancel"].forEach(event => {
        adjustmentControl.addEventListener(event, e => {
          const rect = touchController.getBoundingClientRect();
          const halfController = touchControllerSize() / 2;
          if (rect.left < -halfController || rect.right > window.innerWidth + halfController || rect.top < -halfController || rect.bottom > window.innerHeight + halfController) {
            replaceTouchController();
          }
        });
      });
      
      ["up", "left", "right", "down"].forEach(direction => {
        const control = touchController.children[direction];
        control.addEventListener("touchstart", e => controller[direction] = true);
        control.addEventListener("touchend", e => controller[direction] = false);
        control.addEventListener("touchcancel", e => controller[direction] = false);
      })

      canvas.addEventListener("touchstart", e => controller.interact = true);
      canvas.addEventListener("touchend", e => controller.interact = false);
      canvas.addEventListener("touchcancel", e => controller.interact = false);
    }

    const replaceTouchController = (controllerSize = touchControllerSize()) => {
      if (!useTouchController) return;

      const controller = document.getElementById("touch-controller");

      // resize
      const fontSize = controllerSize / 12;
      controller.style.display = "grid";
      controller.style.gap = controllerSize / 50 + "px";
      controller.style.height = controllerSize + "px";
      controller.style.width = controllerSize + "px";
      controller.style.fontSize = fontSize + "px";

      // reposition
      controller.style.left = canvas.getBoundingClientRect().left + "px";
      controller.style.top = canvas.getBoundingClientRect().top + "px";
    }

    const drawPlayer = () => {
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x - (player.size / 2), player.y - (player.size / 2), player.size, player.size);
    }

    const movePlayer = deltaT => {
      let xSign = Math.sign(player.xVelocity);
      let ySign = Math.sign(player.yVelocity);

      // x momentum
      if (controller.left || controller.right) {
        if (controller.left) player.xVelocity = Math.max(player.xVelocity - player.acceleration, -player.maxVelocity);
        if (controller.right) player.xVelocity = Math.min(player.xVelocity + player.acceleration, player.maxVelocity);

        xSign = Math.sign(player.xVelocity);
      } else {
        if (xSign) player.xVelocity -= player.friction * xSign;
      }

      // y momentum 
      if (controller.up || controller.down) {
        if (controller.up) player.yVelocity = Math.max(player.yVelocity - player.acceleration, -player.maxVelocity);
        if (controller.down) player.yVelocity = Math.min(player.yVelocity + player.acceleration, player.maxVelocity);

        ySign = Math.sign(player.yVelocity);
      } else {
        if (ySign) player.yVelocity -= player.friction * ySign;
      }

      // move
      player.x += player.xVelocity;
      player.y += player.yVelocity;

      // keep the player on screen and handle doorway interactions
      if (player.x > canvas.width) {
        const rightDoors = world.areas[scene].doors.filter(door => door.side == "right" && world.areas[door.destination].unlocked);
        for (let i = 0; i < rightDoors.length; i++) {
          const door = rightDoors[i];
          const doorPosition = door.position ? canvas.height * door.position : canvas.height / 2;

          if (player.y < doorPosition + doorSize && player.y > doorPosition - doorSize) {
            scene = door.destination;
            player.x = 20;
            break;
          }
        }

        player.xVelocity -= player.acceleration * 2;
      }
      if (player.x < 0) {
        const leftDoors = world.areas[scene].doors.filter(door => door.side == "left" && world.areas[door.destination].unlocked);
        for (let i = 0; i < leftDoors.length; i++) {
          const door = leftDoors[i];
          const doorPosition = door.position ? canvas.height * door.position : canvas.height / 2;

          if (player.y < doorPosition + doorSize && player.y > doorPosition - doorSize) {
            scene = door.destination;
            player.x = canvas.width - 20;
            break;
          }
        }

        player.xVelocity += player.acceleration * 2;
      }
      if (player.y > canvas.height) {
        const bottomDoors = world.areas[scene].doors.filter(door => door.side == "bottom" && world.areas[door.destination].unlocked);
        for (let i = 0; i < bottomDoors.length; i++) {
          const door = bottomDoors[i];
          const doorPosition = door.position ? canvas.width * door.position : canvas.width / 2;

          if (player.x < doorPosition + doorSize && player.x > doorPosition - doorSize) {
            scene = door.destination;
            player.y = 20;
            break;
          }
        }
      
        player.yVelocity -= player.acceleration * 2;
      }
      if (player.y < 0) {
        const topDoors = world.areas[scene].doors.filter(door => door.side == "top" && world.areas[door.destination].unlocked);
        for (let i = 0; i < topDoors.length; i++) {
          const door = topDoors[i];
          const doorPosition = door.position ? canvas.width * door.position : canvas.width / 2;

          if (player.x < doorPosition + doorSize && player.x > doorPosition - doorSize) {
            scene = door.destination;
            player.y = canvas.height - 20;
            break;
          }
        }

        player.yVelocity += player.acceleration * 2;
      }

      // keep track of which shop the player is in
      if (world.areas[scene].items) updateShopPositions(world.areas[scene].items);
    }
    //#endregion

    //#region particles
    const moveParticles = () => {
      const areaNames = Object.keys(world.areas);
      for (let i = 0; i < areaNames.length; i++) {
        const area = world.areas[areaNames[i]];
        
        for (let j = 0; j < area.particles.length; j++) {
          const particle = area.particles[j];

          if (scene != areaNames[i] && particle.isCosmetic) continue;
          
          // keep the particle on screen
          if (!particle.ignoreWalls) {
            if (particle.x > canvas.width) particle.xVelocity -= 2;
            else if (particle.x < 0) particle.xVelocity += 2;
            if (particle.y > canvas.height) particle.yVelocity -= 2;
            else if (particle.y < 0) particle.yVelocity += 2;
          }

          if (particle.xVelocity || particle.yVelocity) {
            // move
            particle.x += particle.xVelocity;
            particle.y += particle.yVelocity;

            // slow down
            const xSign = Math.sign(particle.xVelocity);
            const ySign = Math.sign(particle.yVelocity);
            if (xSign) particle.xVelocity -= particle.friction * xSign;
            if (ySign) particle.yVelocity -= particle.friction * ySign;
          }

          if (particle.isCollector) doCollisions({ x: particle.x, y: particle.y, size: particleSize }, area);
          if (particle.onFrame) particle.onFrame();

          // die off
          if (--particle.lifespan < 1) {
            if (particle.onDeath) particle.onDeath();
            area.particles.splice(j, 1);
          }

        }
      }
    }

    const drawParticles = () => {
      const area = world.areas[scene];
      
      for (let i = 0; i < area.particles.length; i++) {
        const particle = area.particles[i];
        if (!showParticles && particle.lifespawn !== Infinity) continue;
        
        if (ctx.fillStyle != particle.color) ctx.fillStyle = particle.color;
        ctx.fillRect(particle.x - particleSize / 2, particle.y - particleSize / 2, particle.size ? particle.size : particleSize, particle.size ? particle.size : particleSize);

        if (particle.stroke) {
          ctx.lineWidth = particle.strokeSize || 1;
          if (ctx.strokeStyle != particle.color) ctx.strokeStyle = particle.color;
          ctx.strokeRect(particle.x - particleSize / 2, particle.y - particleSize / 2, particle.size ? particle.size : particleSize, particle.size ? particle.size : particleSize);
        }
      }
    }
    //#endregion

    //#region targets
    const spawnTarget = (x, y, type) => {
      const main = world.areas["main"];
      const garden = world.areas["garden"];
      
      if (!type) {
        const superPotent = Math.random() < superPotentChance;
        const potency = superPotent ? superPotentValue : Math.random() * maxNormalPotency;
        const breadth = Math.random();
        const confetti = Math.trunc(potency * potencyBonus / 2 + breadth * breadthBonus / 2);

        if (strictTargetAmountLimit && main.targets.length >= maxTargets) {
          points += (confetti + particleBase) * pointsMult;
          return;
        }
        
        const newTarget = {
          x: x ? x : Math.trunc(Math.random() * canvas.width),
          y: y ? y : Math.trunc(Math.random() * canvas.height),
          size: Math.trunc(breadth * breadthSizeBonus + minimumTargetSize),
          color: randomTargetColor(Math.max(potency, .1)),
          confetti: confetti,
          type: type,
          collect: function() {
            const drops = this.confetti + particleBase;
            for (let i = 0; i < drops; i++) {
              main.particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * (drops / 3 + 16) - (drops / 6 + 8)),
                yVelocity: Math.trunc(Math.random() * (drops / 3 + 16) - (drops / 6 + 8)),
                friction: 1,
                lifespan: Math.trunc((normalParticleTime + Math.random() * normalParticleTime / 2) * FPS),
                color: this.color,
                onDeath: () => { points += pointsMult },
              });
            }
            
            main.targets.splice(main.targets.indexOf(this), 1);
          }
        };

        if (superPotent) newTarget.stroke = "#ccc";

        main.targets.push(newTarget);
      } else if (type == "dark") {
        const breadth = Math.random();

        const newTarget = {
          x: x ? x : Math.trunc(Math.random() * canvas.width),
          y: y ? y : Math.trunc(Math.random() * canvas.height),
          size: Math.trunc(breadth * 40 + 40),
          color: "black",
          stroke: "white",
          strokeSize: 2,
          confetti: Math.trunc(breadth * breadthBonus),
          type: type,
          collect: function() {
            const maxVelo = 25 + darkTargetConfettiMult * 2;
            for (let i = 0; i < this.confetti + 20 * darkTargetConfettiMult; i++) {
              // spawn particles that become new generic targets
              main.particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
                yVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
                friction: 1,
                lifespan: Math.trunc((2 + Math.random()) / 2 * FPS),
                color: this.color,
                onDeath: function () { spawnTarget(this.x, this.y) },
              });
            }

            main.specialTargets.splice(main.specialTargets.indexOf(this), 1);
          }
        };

        main.specialTargets.push(newTarget);
      } else if (type == "explosive") {
        const newTarget = {
          x: x ? x : Math.trunc(Math.random() * canvas.width),
          y: y ? y : Math.trunc(Math.random() * canvas.height),
          size: 16,
          color: "red",
          stroke: "maroon",
          strokeSize: 3,
          confetti: minExplosiveConfetti,
          type: type,
          collect: function() {
            for (let i = 0; i < this.confetti * explosiveConfettiMult; i++) {
              main.particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * 140 - 70),
                yVelocity: Math.trunc(Math.random() * 140 - 70),
                friction: 0,
                lifespan: Math.trunc((.4 + Math.random() * .4) * FPS * explosiveLifetimeMult),
                color: "orange",
                isCollector: true,
                onDeath: () => { points += pointsMult },
              });
            }
            
            main.specialTargets.splice(main.specialTargets.indexOf(this), 1);
          }
        };

        main.specialTargets.push(newTarget);
      } else if (type == "gold") {
        const newTarget = {
          x: x ? x : Math.trunc(Math.random() * canvas.width),
          y: y ? y : Math.trunc(Math.random() * canvas.height),
          size: Math.random() * goldTargetSize / 2 + goldTargetSize,
          color: "gold",
          stroke: "#E0B600",
          strokeSize: 3,
          confetti: 0,
          type: type,
          collect: function(parentArray = main.specialTargets) {
            this.size -= goldTargetDecay;
    
            const maxVelo = 25 + 4 * goldTargetDrop;
            for (let i = 0; i < goldTargetDrop; i++) {
              main.particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * maxVelo - maxVelo / 2),
                yVelocity: Math.trunc(Math.random() * maxVelo - maxVelo / 2),
                friction: 1,
                lifespan: Math.trunc((normalParticleTime + Math.random() * normalParticleTime / 2) * FPS),
                color: this.color,
                onDeath: () => {
                  points += 10 * pointsMult;
                },
              });
            }

            if (this.size < goldTargetMinSize) {
              parentArray.splice(parentArray.indexOf(this), 1);
            }
          }
        };

        main.specialTargets.push(newTarget);
      } else if (type == "rain") {
        const newTarget = {
          x: Math.trunc(Math.random() * canvas.width),
          y: Math.trunc(Math.random() * canvas.height),
          size: 18,
          color: "#6495ED84",
          confetti: 50,
          type: type,
          collect: function() {
            // start rain
            if (!rainDuration) {
              rainIntensity = Math.random() * .5 + .5;
              rainSpeed = Math.random() * 10 + 20 * rainIntensity;
              rainAngle = Math.random() * 4 - 2;
              rainAmount = Math.ceil(Math.random() * 4 * rainIntensity);
            }
            rainDuration = 3600;

            // water plots
            for (let i = 0; i < gardenPlots.length; i++) {
              const plot = gardenPlots[i];
              plot.wetness = Math.trunc(Math.random() * wetRandRange + minWetness);
            }
            world.areas["farmers market"].items.find(e => e.id == "water plot").refresh();

            // begin target-collection splash effect
            for (let i = 0; i < this.confetti; i++) {
              world.areas["garden"].particles.push({
                x: this.x,
                y: this.y,
                xVelocity: Math.trunc(Math.random() * 40 - 20),
                yVelocity: Math.trunc(Math.random() * 40 - 20),
                friction: 1,
                lifespan: Math.trunc((.1 + Math.random() / 4) * FPS),
                color: this.color,
                isCosmetic: true,
              });
            }

            garden.specialTargets.splice(garden.specialTargets.indexOf(this), 1);
          }
        };

        garden.specialTargets.push(newTarget);
      }
    }

    const drawTargets = targetArray => {
      for (let i = 0; i < targetArray.length; i++) {
        const target = targetArray[i];

        if (target.stroke) {
          ctx.strokeStyle = target.stroke;
          ctx.lineWidth = target.strokeSize || 1;
          ctx.strokeRect(target.x - (target.size / 2), target.y - (target.size / 2), target.size, target.size);
        }

        ctx.fillStyle = target.color;
        ctx.fillRect(target.x - (target.size / 2), target.y - (target.size / 2), target.size, target.size);
      }
    }

    const collectTarget = target => {
      const main = world.areas["main"];
      const garden = world.areas["garden"];
      target.collect();

      if (target.type == "gold" && goldAutoCollect) {
          main.autoTargets.push(
            ...main.specialTargets.splice(main.specialTargets.indexOf(target), 1)
          );

      } else if (target.type == "rain") {        
        garden.specialTargets.splice(garden.specialTargets.indexOf(target), 1);
      }
    }

    const doAutoCollection = () => {
      for (let i = 0; i < Object.keys(world.areas).length; i++) {
        const targetArray = world.areas[Object.keys(world.areas)[i]].autoTargets;
        
        if (!targetArray) continue;

        for (let j = 0; j < targetArray.length; j++) {
          targetArray[j].collect(targetArray);
        }
      }
    }

    //#region utility functions
    const randomTargetColor = strength => {
      const h = Math.floor(Math.random() * 256);
      const s = Math.trunc(strength * 100);
      const l = 50;
      const a = Math.max(strength.toFixed(2), .3);
      return `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    
    const randomSign = () => {
      return Math.random() < 0.5 ? -1 : 1;
    }
    //#endregion

    const drawText = () => {
      // general styles
      ctx.fillStyle = "black";
      ctx.lineWidth = 3;
      ctx.strokeStyle = "white";
      ctx.font = "18px serif";

      if (showVersionCode) {
        // draw version code
        ctx.textAlign = "left";
        ctx.fillText(version, 10, 20);
      }

      if (showCurrency) {
        const drawCurrencies = startHeight => {
          ctx.textAlign = "center";
          if (world.areas["garden"].unlocked) {
            startHeight -= 20
            ctx.strokeText(`Seeds: ${seeds}`, canvas.width / 2, startHeight + 20);
            ctx.fillText(`Seeds: ${seeds}`, canvas.width / 2, startHeight + 20);
          }
  
          ctx.strokeText(`Points: ${points}`, canvas.width / 2, startHeight);
          ctx.fillText(`Points: ${points}`, canvas.width / 2, startHeight);
        }
  
        ctx.textAlign = "center";
        if (world.areas[scene].doors.find(door => door.side == "bottom")) {
          drawCurrencies(45);
        } else {
          drawCurrencies(canvas.height - 20);
        }
      }
    }

    const drawDoors = () => {
      ctx.lineWidth = 3;
      ctx.strokeStyle = "white";
      ctx.font = "18px serif";

      const theseDoors = world.areas[scene].doors.filter(door => world.areas[door.destination].unlocked);
      for (let i = 0; i < theseDoors.length; i++) {
        const door = theseDoors[i];

        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        
        if (door.side == "right") {
          const doorPosition = door.position ? canvas.height * door.position : canvas.height / 2;

          if (showDoorLabel) {
            ctx.textAlign = "right";
            ctx.strokeText(`${door.destination} `, canvas.width - 20, doorPosition);
            ctx.fillText(`${door.destination} `, canvas.width - 20, doorPosition);
          }

          if (showDoorway) {
            ctx.fillStyle = doorColor;
            ctx.fillRect(canvas.width, doorPosition - doorSize, -5, doorSize * 2);
          }
        } else if (door.side == "left") {
          const doorPosition = door.position ? canvas.height * door.position : canvas.height / 2;

          if (showDoorLabel) {
            ctx.textAlign = "left";
            ctx.strokeText(` ${door.destination}`, 20, doorPosition);
            ctx.fillText(` ${door.destination}`, 20, doorPosition);
          }

          if (showDoorway) {
            ctx.fillStyle = doorColor;
            ctx.fillRect(0, doorPosition - doorSize, 5, doorSize * 2);
          }
        }
        if (door.side == "top") {
          const doorPosition = door.position ? canvas.width * door.position : canvas.width / 2;

          if (showDoorLabel) {
            ctx.strokeText("", doorPosition, 20);
            ctx.fillText("", doorPosition, 20);
            ctx.strokeText(door.destination, doorPosition, 35);
            ctx.fillText(door.destination, doorPosition, 35);
          }

          if (showDoorway) {
            ctx.fillStyle = doorColor;
            ctx.fillRect(doorPosition - doorSize, 0, doorSize * 2, 5);
          }
        } else if (door.side == "bottom") {
          const doorPosition = (door.position ? canvas.width * door.position : canvas.width / 2);

          if (showDoorLabel) {
            ctx.textAlign = "bottom";
            ctx.strokeText("", doorPosition, canvas.height - 20);
            ctx.fillText("", doorPosition, canvas.height - 20);
            ctx.strokeText(door.destination, doorPosition, canvas.height - 35);
            ctx.fillText(door.destination, doorPosition, canvas.height - 35);
          }

          if (showDoorway) {
            ctx.fillStyle = doorColor;
            ctx.fillRect(doorPosition - doorSize, canvas.height, doorSize * 2,  -5);
          }
        }
      }
    }

    const randomEvents = () => {      
      const main = world.areas["main"];
      
      // main targets
      if (Math.random() < targetChance && main.targets.length < maxTargets) spawnTarget();
      if (darkTargetUnlocked && Math.random() < (strictTargetAmountLimit ? darkTargetChance : darkTargetChance / 2) * specialTargetRateMult && main.specialTargets.length < maxSpecialTargets && main.targets.length < Math.max(safeMaxTargets, maxTargets + 10)) spawnTarget(null, null, "dark");
      if (explosiveTargetUnlocked && Math.random() < explosiveTargetChance * specialTargetRateMult && main.specialTargets.length < maxSpecialTargets) spawnTarget(null, null, "explosive");
      if (goldTargetUnlocked && Math.random() < goldTargetChance * specialTargetRateMult && main.specialTargets.length < maxSpecialTargets) spawnTarget(null, null, "gold");

      // garden targets
      if (rainUnlocked && Math.random() < rainTargetChance && world.areas["garden"].specialTargets.length < maxGardenSpecialTargets) spawnTarget(null, null, "rain");
    }

    const spawnRain = () => {
      for (let i = 0; i < rainAmount; i++) {
        world.areas["garden"].particles.push({
          x: Math.random() * (canvas.width + 60) - 30,
          y: 0,
          xVelocity: rainAngle,
          yVelocity: rainSpeed,
          friction: 0,
          lifespan: (Math.random() * (canvas.height * 1.25 / rainSpeed / 60)) * FPS,
          color: "#6495ED84",
          ignoreWalls: true,
          isCosmetic: true,
        });
      }

      rainDuration -= 1;
    }

    const update = () => {
      movePlayer();
      moveParticles();
      randomEvents();

      growCrops();
      if (!rainDuration) {
        updateGardenWetness();
      } else if (showRain && scene == "garden") {
        spawnRain();
      }

      doCollisions(player, world.areas[scene]);

      if (shopFocus) detectPurchase();

      doAutoCollection();
    }

    const render = () => {
      const area = world.areas[scene];

      canvas.style.backgroundColor = area.color;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (scene == "garden") drawGardenPlots();
      
      if (area.items) drawShopItems(area.items);
      if (area.targets && showNormalTargets) drawTargets(area.targets);
      if (area.specialTargets && showSpecialTargets) drawTargets(area.specialTargets);
      if (area.autoTargets && showSpecialTargets) drawTargets(area.autoTargets);

      drawParticles();
      drawText();
      if (showDoorLabel || showDoorway) drawDoors();
      drawPlayer();

      if (shopFocus) {
        drawPurchaseButton();
      }
    }

    //#region garden
    let gardenPlots = [];

    const harvestCrop = crop => {
      for (let i = 0; i < crop.confetti + cropHarvestBonus; i++) {
        world.areas["garden"].particles.push({
          x: crop.x,
          y: crop.y,
          xVelocity: Math.trunc(Math.random() * 14 - 7),
          yVelocity: Math.trunc(Math.random() * 14 - 7),
          friction: 1,
          lifespan: Math.trunc((1 + Math.random() * .5) * FPS),
          color: `hsl(120, 80%, 40%)`,
          onDeath: () => seeds += 1,
        });
      }

      crop.growth = 0;
    }

    const growCrops = () => {
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];

        for (let j = 0; j < plot.strips.length; j++) {
          const strip = plot.strips[j];

          for (let k = 0; k < strip.length; k++) {
            const crop = strip[k];

            if (crop.growth < 1 && Math.random() < cropGrowthChance) crop.growth = Math.min(crop.growth + .1 + (plot.fertility ? .15 : 0) + (plot.wetness ? .1 : 0), 1);
          }
        }
      }
    }

    const updateGardenWetness = () => {
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];

        // if not zero, -1, then, if zero, update shop item
        if (plot.wetness && !--plot.wetness) farmersMarketItems.find(e => e.id == "water plot").refresh();
      }
    }

    const gardenPadding = 100;
    const drawGardenPlots = () => {
      const plotLength = 250;
      const plotHeight = 200;

      const plotsPerGridRow = Math.min(gardenPlots.length, Math.floor((canvas.width - gardenPadding * 2) / plotLength));
      const gridRows = Math.ceil(gardenPlots.length / plotsPerGridRow);
      const plotGapX = (canvas.width - gardenPadding * 2 - plotsPerGridRow * plotLength) / Math.max(1, plotsPerGridRow - 1);
      const plotGapY = (canvas.height - gardenPadding * 2 - gridRows * plotHeight) / Math.max(1, gridRows - 1);

      const stripsPerPlot = 5;
      const plotPadding = 10;
      const stripLength = plotLength - plotPadding * 2;
      const stripHeight = (plotHeight - plotPadding * 2 - plotPadding * (stripsPerPlot - 1)) / stripsPerPlot;

      const cropsPerStrip = 5;
      const cropGap = stripLength / (cropsPerStrip + 1);

      // draw plot
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];
        const plotColor = `hsl(36, 39%, ${60 - (plot.fertility ? 15 : 0) - (plot.wetness ? 15 : 0)}%)`;
        const gardenGridX = i % plotsPerGridRow;
        const gardenGridY = Math.floor(i / plotsPerGridRow);

        plot.x = gardenPadding + plotLength * gardenGridX + plotGapX * gardenGridX;
        plot.y = gardenPadding + plotHeight * gardenGridY + plotGapY * gardenGridY;

        ctx.fillStyle = plotColor;
        ctx.fillRect(plot.x, plot.y, plotLength, plotHeight);

        // draw strips
        for (let j = 0; j < plot.strips.length; j++) {
          const strip = plot.strips[j];

          const stripColor = `hsl(36, 39%, ${50 - (plot.fertility ? 15 : 0) - (plot.wetness ? 15 : 0)}%)`;

          const stripX = plot.x + plotPadding;
          const stripY = plot.y + plotPadding + j * stripHeight + j * plotPadding;

          ctx.fillStyle = stripColor;
          ctx.fillRect(stripX, stripY, stripLength, stripHeight);

          // draw crops
          for (let k = 0; k < strip.length; k++) {
            const crop = strip[k];

            crop.x = stripX + cropGap * (k + 1);
            crop.y = stripY + stripHeight / 2;
            const cropColor = crop.growth == 1 ? "hsl(120, 100%, 33%)" : `hsl(120, ${(crop.growth * .75 + .25) * 100}%, ${(1 - (crop.growth * .4 + .2)) * 100}%)`;
            const sizeMod = crop.growth * .8 + .2;

            ctx.fillStyle = cropColor;
            ctx.fillRect(crop.x - maxCropSize * sizeMod / 2, crop.y - maxCropSize * sizeMod / 2, maxCropSize * sizeMod, maxCropSize * sizeMod);
          }
        }
      }
    }

    //#endregion

    //#region shop
    const purchaseIsValid = shopItem => {
      return (shopItem.price ? shopItem.price <= points : true) && (shopItem.seedPrice ? shopItem.seedPrice <= seeds : true) && (shopItem.maxLevel ? shopItem.level < shopItem.maxLevel : true);
    }

    const detectPurchase = () => {
      if (!controller.interact) return;
      const area = world.areas[scene];

      if (scene == "settings") {
        shopFocus.onPurchase();
      } else {
        shopFocus.level += 1;
        points -= shopFocus.price;
        if (shopFocus.seedPrice) seeds -= shopFocus.seedPrice;
        shopFocus.onPurchase();

        if (showParticles) {
          const drops = shopFocus.level == shopFocus.maxLevel ? Math.min(25 * shopFocus.level, 150) : Math.min(7 * shopFocus.level, 100);
          const maxVelo = drops / 8 + 10;
          for (let i = 0; i < drops; i++) {
            area.particles.push({
              x: shopFocus.x,
              y: shopFocus.y,
              xVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
              yVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
              friction: 1,
              lifespan: Math.trunc((.25 + Math.random() * .25) * FPS),
              color: shopFocus.level == shopFocus.maxLevel ? "hsl(47, 100%, 50%)" : "rgb(0, 200, 0)",
            });
          }
        }
      }

      updateShopPositions(area.items);
      controller.interact = false;
    }

    const drawPurchaseButton = () => {
      ctx.font = "40px sans-serif";
      ctx.textAlign = "center";
      if (ctx.fillStyle != "lime") ctx.fillStyle = "lime";
      if (ctx.lineWidth != 3) ctx.lineWidth = 3;
      if (ctx.strokeStyle != "black") ctx.strokeStyle = "black";
      ctx.strokeText(interactionMessage, player.x, player.y - 50);
      ctx.fillText(interactionMessage, player.x, player.y - 50);
    }

    const updateShopPositions = itemArray => {
      itemArray = itemArray.filter(item => item.unlocked);
      const shopItemsPerRow = 5;
      const shopRows = 4;
      const shopPadding = 3 * itemButtonSize;
      const rowGap = (canvas.height - shopPadding * 2 - shopRows * itemButtonSize) / (shopRows - 1);
      const colGap = (canvas.width - shopPadding * 2 - shopItemsPerRow * itemButtonSize) / (shopItemsPerRow - 1);

      for (let i = 0; i < itemArray.length; i++) {
        const item = itemArray[i];

        const row = Math.floor(i / shopItemsPerRow) + 1;
        const col = i % shopItemsPerRow + 1;

        item.x = shopPadding + (col - 1) * itemButtonSize + (col - 1) * colGap + itemButtonSize / 2;
        item.y = shopPadding + (row - 1) * itemButtonSize + (row - 1) * rowGap + itemButtonSize / 2;
      }
    }

    const drawShopItems = itemArray => {
      itemArray = itemArray.filter(item => item.unlocked);

      for (let i = 0; i < itemArray.length; i++) {
        const item = itemArray[i]

        // draw button
        if (item.color) {
          ctx.fillStyle = item.color;
        } else if (item.level === item.maxLevel) {
          ctx.fillStyle = "hsl(47, 100%, 50%)";
        } else if (item.price <= points && (item.seedPrice ? item.seedPrice <= seeds : true)) {
          ctx.fillStyle = "rgb(0, 200, 0)";
        } else {
          ctx.fillStyle = "rgb(200, 0, 0)";
        }
        ctx.fillRect(item.x - itemButtonSize / 2, item.y - itemButtonSize / 2, itemButtonSize, itemButtonSize);
        if (item.stroke) {
          ctx.strokeStyle = item.stroke;
          ctx.strokeRect(item.x - itemButtonSize / 2, item.y - itemButtonSize / 2, itemButtonSize, itemButtonSize);
        }

        // draw "new!" badge
        if (scene != "settings" && item.level == 0 && !item.purchasedBefore) {
          ctx.font = "bold 20px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = purchaseIsValid(item) ? "rgb(200, 0, 0)" : "rgb(200, 0, 0)";
          ctx.fillText("new!", item.x, item.y - itemButtonSize / 1.5);
        }

        // draw item title
        ctx.font = "20px serif";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        const titleText = item.detail ? `${item.title} : ${item.detail}` : item.title;
        ctx.fillText(titleText, item.x, item.y + itemButtonSize);

        if (!(item.level < item.maxLevel)) continue;

        // draw pricing
        const tempStrings = [];
        if (item.price) tempStrings.push(`${item.price} points`);
        if (item.seedPrice) tempStrings.push(`${item.seedPrice} seeds`);
        if (item.maxLevel && item.maxLevel > 1) tempStrings.push(`${item.level}/${item.maxLevel}`);
        ctx.fillText(tempStrings.join(" : "), item.x, item.y + itemButtonSize + 20);
      }
    }
    //#endregion

    const gameLoop = () => {
      const now = Date.now();
      const deltaT = (now - lastFrameTime) / 1000; // seconds
      lastFrameTime = now;

      update();
      render();
      setTimeout(gameLoop, 1000 / FPS);
    }

    let lastFrameTime = Date.now();

    // start the game with a few targets
    for (let i = 0; i < 5; i++) spawnTarget();

    //#region scale the canvas to the screen
    function scaleCanvas() {      
      const scale = {
        x: userHasTouchScreen ? window.outerWidth / canvas.width : window.innerWidth / canvas.width,
        y: userHasTouchScreen ? window.outerHeight / canvas.height : window.innerHeight / canvas.height
      }

      const fitCanvasToScreenHeight = scale.x > scale.y;

      // Apply scaling
      if (fitCanvasToScreenHeight) {
        canvas.style.transformOrigin = "top";
        canvas.style.transform = `scale(${scale.y})`;
      } else {
        canvas.style.transformOrigin = "top";
        canvas.style.transform = `scale(${scale.x})`;
      }
    }
    addEventListener("resize", ()=>{
      scaleCanvas();
      if (userHasTouchScreen) replaceTouchController(touchControllerSize());
    });
    //#endregion
    
    scaleCanvas();
    setupPlayerControls();
    gameLoop();
          
    //#region warn against using portrait screen orientation
    if (!screen.orientation.type.includes("landscape")) alert("This game is probably better in landscape orientation.");
    screen.orientation.addEventListener("change", item => {
      if (!screen.orientation.type.includes("landscape"))
        alert("This game is probably better in landscape orientation.");
    });
    //#endregion
  </script>
</body>

</html>
