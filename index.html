<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas</title>
  <style>
    html {
      height: 100%;
      background-color: linen;
    }
    body {
      margin: 0;
      align-items: center;
      justify-content: center;
      display: grid; 


      overflow: hidden;
    }

    canvas {
      background-color: #ffffff;
    }
  </style>
</head>

<body>
  <div id="main">
    <canvas id="canvas" width="1600" height="900"></canvas>
  </div>

  <script defer>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const FPS = 60;
    const keys = {};
    const version = "v0.4.0";

    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 10,
      xVelocity: 0,
      yVelocity: 0,
      acceleration: 2,
      friction: 2,
      maxVelocity: 14,
      color: "rgb(255, 0, 0, 1)",
    }

    let scene = "main";
    let sceneDoors = { "main": "shop" };
    const doorSize = 60;

    let shopFocus;
    const shopButtonSize = 50;
    const minimumLabelWidth = 200;

    let points = 100000000;
    let pointsMult = 1;
    let seeds = 100000000;
    let particleBase = 1; // points from targets
    const particleSize = 8;

    let normalParticleTime = 2;
    let breadthSizeBonus = 10; // increase target breadth effectiveness on average
    let minimumTargetSize = 30;
    let breadthBonus = 5; // points from target breadth
    let potencyBonus = 10; // points from target potency
    let minimumPotency = 0; // minimum potency (1=100%)
    let maxNormalPotency = .3; // maximum potency (1=100%)
    let superPotentChance = .5; // chance for 100% potency (1=100%)
    let superPotentValue = 3 // amount of bonus particles for super potency

    const targets = [];
    const specialTargets = [];
    const autoCollectTargets = [];
    const gardenTargets = [];
    //
    const particles = [];
    const shopParticles = [];
    const gardenParticles = [];

    let maxTargets = 10; // (prevents lag and balances gameplay)
    let targetChance = .01; // chance for a new target to appear each frame (1=100%)
    let maxSpecialTargets = 1; // (balances gameplay)
    let specialTargetRateMult = 1; // increases the rate of all special target appearances
    //
    let darkTargetUnlocked = false;
    let darkTargetChance = .0005; // chance for a new dark target to appear each frame (1=100%)
    let darkTargetConfettiMult = 1; // amount of particles from dark targets
    //
    let explosiveTargetUnlocked = false;
    let explosiveTargetChance = .0005; // chance for a new dark target to appear each frame (1=100%)
    let explosiveConfettiMult = 1;
    let explosiveLifetimeMult = 1;
    let minExplosiveConfetti = 30;
    //
    let goldTargetUnlocked = false;
    let goldTargetChance = .0005; // chance for a new gold target to appear each frame (1=100%)
    let goldTargetDecay = 1; // size reduction per frame of the gold target
    let goldTargetSize = 50; // size reduction per frame of the gold target
    const goldTargetMinSize = 25; // minimum size before a gold target disappears
    let goldTargetDrop = 1; // gold target shoots 2 particles per frame instead of 1
    let goldAutoCollect = false; 

    let gardenIsUnlocked = false; // boolean determines whether the garden is enabled
    const maxGardenPlots = 15; // the maximum allowed number of garden plots to be displayed in the garden area
    let cropGrowthChance = .0005; // chance for garden crops to increase in their 'growth' value by some amount
    const maxCropSize = 28; // maximum physical size for crop display and collision
    let cropHarvestBonus = 0; // multiplies the amount of seeds harvested from garden crops
    let gardenStrips = 0; // sum count of garden strips across all plots
    let rabbitSpeed = 15; // max rabbit speed
    let minWetLifespan = 3000; // minimum amount of frames before garden plot has isWet set to "false"
    let wetRandRange = 2000; // the range of frames after the minWetLifespan for which a garden plot may remain wet
    let sunlampUnlocked = false;
    const maxGardenTargets = 2;
    //
    let rainUnlocked = false;
    let rainTargetChance = .0001; // .0001 = 1/10000 frames
    let rainDuration = 0; // duration of the rain event
    let rainSpeed = 30; // visible speed of the rain particles
    let rainAngle = 0; // x velocity for the rain particles
    let rainAmount = 3;  // amount of rain particles to be spawned each frame during rain
    let rainIntensity = 1; // limiting value that multiplies against other rain values

    let turtleSpeed = 6;

    const unlockShopItems = (...itemIDs) => {
      for (let i = 0; i < itemIDs.length; i++) {
        const item = shopItems.find(e => e.id == itemIDs[i]);
        item.unlocked = true;
      }
    }

    const unlockFarmersMarketItems = (...itemIDs) => {
      for (let i = 0; i < itemIDs.length; i++) {
        const item = farmersMarketItems.find(e => e.id == itemIDs[i]);
        item.unlocked = true;
      }
    }

    let shopItems = [
      // basic upgrades
      {
        id: "drop per target",
        title: "+1 Drop Per Target",
        unlocked: true,
        level: 0,
        maxLevel: 14,
        price: 20,
        x: undefined,
        y: undefined,
        detail: particleBase,
        onPurchase: function () {
          this.price += 30 * this.level;
          particleBase += 1;
          this.detail = particleBase;

          if (this.level == 1) {
            unlockShopItems("max targets");
          }

          if (this.level + shopItems.find(e => e.id == "max targets").level == 8) {
            unlockShopItems("double target spawn", "half pick up time");
          }

          if (this.level == this.maxLevel) {
            unlockShopItems("double points");

            this.detail = null;
            this.title = `+${particleBase} Drops Per Target`;
          }
        }
      },
      {
        id: "max targets",
        title: "+10 Max Targets",
        unlocked: false,
        level: 0,
        maxLevel: 19,
        price: 100,
        x: undefined,
        y: undefined,
        detail: maxTargets,
        onPurchase: function () {
          if (this.level == 1) {
            unlockShopItems("max potency", "max target width", "unlock garden");
          }
          this.price = Math.round(this.price * 1.5);
          maxTargets += 10;
          this.detail = maxTargets;

          if (this.level + shopItems.find(e => e.id == "drop per target").level == 8) {
            unlockShopItems("double target spawn", "half pick up time");
          }

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${maxTargets} Max Targets`;
          }
        }
      },
      {
        id: "max potency",
        title: "+5% Max Potency",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 100,
        x: undefined,
        y: undefined,
        detail: `${Math.round(maxNormalPotency * 100)}%`,
        onPurchase: function () {
          if (this.level == 1) {
            unlockShopItems("super potent chance")
          }
          this.price += 200;
          maxNormalPotency += .05;
          this.detail = `${Math.round(maxNormalPotency * 100)}%`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${Math.round(maxNormalPotency * 100)}% Max Potency`;
          }
        }
      },
      {
        id: "super potent chance",
        title: "+1% Super Potent Chance",
        unlocked: false,
        level: 0,
        maxLevel: 25,
        price: 50,
        x: undefined,
        y: undefined,
        detail: `${Math.round(superPotentChance * 100)}%`,
        onPurchase: function () {
          superPotentChance += .01;
          this.price += 50;
          this.detail = `${Math.round(superPotentChance * 100)}%`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${Math.round(superPotentChance * 100)}% Super Potent Chance`;
          }
        }
      },
      {
        id: "max target width",
        title: "+2 Max Target Width",
        unlocked: false,
        level: 0,
        maxLevel: 40,
        price: 50,
        x: undefined,
        y: undefined,
        detail: breadthSizeBonus,
        onPurchase: function () {
          this.price += 50;
          breadthSizeBonus += 2;
          this.detail = breadthSizeBonus;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `+${breadthSizeBonus} Max Target Width`;
          }
        }
      },

      // intermediate 
      {
        id: "double target spawn",
        title: "x2 Target Spawn Rate",
        unlocked: false,
        level: 0,
        maxLevel: 6,
        price: 100,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          if (this.level == 1) {
            unlockShopItems("unlock explosive target")
          }

          this.price *= 5;
          targetChance *= 2;
          this.detail = `x${2 ** this.level}`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `x${2 ** this.level} Target Spawn Rate`;
          }
        }
      },
      {
        id: "half pick up time",
        title: "Half Drop Pick-Up Time",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 100,
        x: undefined,
        y: undefined,
        detail: normalParticleTime,
        onPurchase: function () {
          if (this.level == 1) {
            unlockShopItems("turtle");
          }
          this.price *= 10;
          normalParticleTime /= 2;
          this.detail = normalParticleTime;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${normalParticleTime} Drop Pick-Up Time`;
          }
        }
      },

      // explosive
      {
        id: "unlock explosive target",
        title: "Unlock Explosive Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 200,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          explosiveTargetUnlocked = true;

          unlockShopItems("more explosive targets", "double explosive target drops", "unlock dark target", "max special drops", "double special target rate");

          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more explosive targets",
        title: "20% More Explosive Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 300,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          explosiveTargetChance *= 1.2;
          this.price = Math.round(this.price * 1.2);

          if (this.level == this.maxLevel) {
            this.title = "More Explosive Targets";
          }
        }
      },
      {
        id: "double explosive target drops",
        title: "x2 Explosive Target Drops",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 500,
        x: undefined,
        y: undefined,
        detail: null,
        unlocked: false,
        onPurchase: function () {
          explosiveConfettiMult *= 2;
          this.price *= 5;

          if (this.level == this.maxLevel) {
            this.title = `x${2 ** this.maxLevel} Explosive Target Drops`;
          }
        }
      },
      {
        id: "double explosive time",
        title: "Double Explosive Time",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 100000,
        seedPrice: 10000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          explosiveLifetimeMult *= 2;
        }
      },

      // dark
      {
        id: "unlock dark target",
        title: "Unlock Dark Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 500,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          darkTargetUnlocked = true;
          unlockShopItems("more dark targets", "double dark target drops", "unlock gold target");
          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more dark targets",
        title: "20% More Dark Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 400,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          darkTargetChance *= 1.2;

          if (this.level == this.maxLevel) {
            this.title = "More Dark Targets";
          }
        }
      },
      {
        id: "double dark target drops",
        title: "2x Dark Target Drops",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 1500,
        x: undefined,
        y: undefined,
        detail: `x${darkTargetConfettiMult}`,
        unlocked: false,
        onPurchase: function () {
          darkTargetConfettiMult *= 2;
          this.price *= 2;
          this.detail = `x${darkTargetConfettiMult}`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `x${darkTargetConfettiMult} Dark Target Drops`;
          }
        }
      },

      // gold
      {
        id: "unlock gold target",
        title: "Unlock Gold Target",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 1000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          goldTargetUnlocked = true;
          unlockShopItems("more gold targets", "double gold target drop", "easy collect gold");
          shopItems.splice(shopItems.indexOf(this), 1);
        }
      },
      {
        id: "more gold targets",
        title: "20% More Gold Targets",
        unlocked: false,
        level: 0,
        maxLevel: 10,
        price: 500,
        x: undefined,
        y: undefined,
        detail: goldTargetDrop,
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          goldTargetChance *= 1.2;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = "More Gold Targets";
          }
        }
      },
      {
        id: "double gold target drop",
        title: "2x Gold Target Drop",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 5000,
        x: undefined,
        y: undefined,
        detail: goldTargetDrop,
        onPurchase: function () {
          goldTargetDrop *= 2;
          this.price *= 5;
          this.detail = goldTargetDrop;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `x${goldTargetDrop} Gold Target Drops`;
          }
        }
      },
      {
        id: "easy collect gold",
        title: "Easy-Collect Gold",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 10000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          goldAutoCollect = true;
        }
      },

      // other special
      {
        id: "double special target rate",
        title: "x2 Special Target Rate",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 1000,
        x: undefined,
        y: undefined,
        detail: `x${specialTargetRateMult}`,
        onPurchase: function () {
          if (this.level == 1) {
            unlockShopItems("double explosive time");
          }

          this.price *= 10;
          specialTargetRateMult *= 2;
          this.detail = `x${specialTargetRateMult}`;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `x${specialTargetRateMult} Special Target Rate`;
          }
        }
      },
      {
        id: "max special drops",
        title: "+1 Max Special Targets",
        unlocked: false,
        level: 0,
        maxLevel: 9,
        price: 1000,
        x: undefined,
        y: undefined,
        detail: maxSpecialTargets,
        onPurchase: function () {
          this.price = Math.round(this.price * 1.2);
          maxSpecialTargets += 1;
          this.detail = maxSpecialTargets;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${maxSpecialTargets} Max Special Targets`;
          }
        }
      },

      // advanced
      {
        id: "double points",
        title: "x2 Points",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 300000,
        seedPrice: 1000,
        x: undefined,
        y: undefined,
        detail: `x${pointsMult}`,
        onPurchase: function () {
          this.price += 200000 * this.level;
          this.seedPrice += 3000 * this.level;
          pointsMult *= 2;
          if (this.level < this.maxLevel) {
            this.detail = `x${pointsMult}`;
          } else {
            this.detail = null;
            this.title = `x${pointsMult} Points`;
          }
        }
      },
      {
        id: "turtle",
        title: "+1 Turtle",
        unlocked: false,
        level: 0,
        maxLevel: 2,
        price: 100000,
        seedPrice: 10000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          const signX = Math.sign(Math.random() - .5) || 1;
          const signY = Math.sign(Math.random() - .5) || 1;

          particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            xVelocity: signX * turtleSpeed,
            yVelocity: signY * turtleSpeed,
            friction: 0,
            lifespan: Infinity,
            color: "green",
            isCollector: true,
            size: 16,
          });

          this.price *= 5;
          this.seedPrice *= 3;

          if (this.level == this.maxLevel) {
            this.title = `${this.maxLevel} Turtles`;
          }
        }
      },
      {
        id: "unlock garden",
        title: "Unlock Garden Area",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 250,
        x: undefined,
        y: undefined,
        onPurchase: function () {
          gardenIsUnlocked = true;
          sceneDoors["garden"] = "farmers market";
          this.title = "Garden Unlocked"
        }
      }
    ];

    let farmersMarketItems = [
      // plot upgrades
      {
        id: "garden plot",
        title: "+1 Garden Plot",
        unlocked: true,
        level: 0,
        maxLevel: maxGardenPlots,
        price: 0,
        seedPrice: 0,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          gardenPlots.push({
            x: null, y: null,
            isWet: rainDuration > 0,
            wetLifespan: Math.trunc(Math.random() * wetRandRange + minWetLifespan),
            isFertile: false,
            strips: [],
          });
          this.price = 15000 * this.level;
          this.seedPrice = 100 * this.level;

          if (this.level == 1) {
            unlockFarmersMarketItems("garden row", "water plot", "enrich plot");
          }

          if (this.level == 5) {
            unlockFarmersMarketItems("sunlamp", "unlock rain");
          }

          if (this.level == this.maxLevel) {
            this.title = `${gardenPlots.length} Garden Plots`;
          }
          
          // update the water + enrich upgrades
          farmersMarketItems.find(e => e.id == "water plot").refresh();
          farmersMarketItems.find(e => e.id == "enrich plot").refresh();

          // update the rows upgrade
          farmersMarketItems.find(e => e.id == "garden row").maxLevel = gardenPlots.length * 5;
        }
      },
      {
        id: "garden row",
        title: "+1 Garden Row",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 0,
        seedPrice: 0,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          if (this.level == 1) {
            unlockFarmersMarketItems("crop harvest", "rabbit");
          }

          gardenStrips += 1;
          gardenPlots[Math.floor((gardenStrips - 1) / 5)].strips.push([{
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          }, {
            x: null, y: null,
            growth: 0,
            confetti: 2 + Math.round(Math.random()),
          },]);
          this.price = 2500 * this.level;
          this.seedPrice = 20 * this.level;
          this.detail = gardenStrips;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `${gardenStrips} Garden Rows`;
          }
        }
      },

      {
        id: "water plot",
        title: "Water 1 Plot",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 2000,
        seedPrice: 10,
        x: undefined,
        y: undefined,
        detail: null,
        purchasedBefore: true,
        onPurchase: function () {
          for (let i = 0; i < gardenPlots.length; i++) {
            const plot = gardenPlots[i];
            if (plot.isWet) continue;
            plot.isWet = true;
            plot.wetLifespan = Math.trunc(Math.random() * wetRandRange + minWetLifespan);
            break;
          }

          this.price = 2000 * this.level;
          this.seedPrice = 200 * this.level;
          this.purchasedBefore = false;

          if (this.level == this.maxLevel) {
            this.title = "All Plots Watered";
          }
        },
        refresh: function() {
          this.maxLevel = gardenPlots.length;
          this.level = gardenPlots.filter(plot => plot.isWet).length;
          this.price = 2000 * this.level;
          this.seedPrice = 200 * this.level;
          
          if (this.level == this.maxLevel) {
            this.title = "All Plots Watered";
          } else {
            this.title = "Water 1 Plot";
          }
        },
      },
      {
        id: "enrich plot",
        title: "Enrich 1 Plot",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 5000,
        seedPrice: 10,
        x: undefined,
        y: undefined,
        detail: null,
        purchasedBefore: true,
        onPurchase: function () {
          for (let i = 0; i < gardenPlots.length; i++) {
            const plot = gardenPlots[i];
            if (plot.isFertile) continue;
            plot.isFertile = true;
            break;
          }
          this.price = 5000 * this.level;
          this.seedPrice = 200 * this.level;
          this.purchasedBefore = false;

          if (this.level == this.maxLevel) {
            this.title = "All Plots Enriched";
          }
        },
        refresh: function () {
          this.maxLevel = gardenPlots.length;
          this.level = gardenPlots.filter(plot => plot.isWet).length;
          this.price = 5000 * this.level;
          this.seedPrice = 200 * this.level;

          if (this.level == this.maxLevel) {
            this.title = "All Plots Enriched";
          } else {
            this.title = "Enrich 1 Plot";
          }
        },
      },

      // general upgrades
      {
        id: "crop harvest",
        title: "+1 Crop Harvest",
        unlocked: false,
        level: 0,
        maxLevel: 9,
        price: 1000,
        seedPrice: 10,
        x: undefined,
        y: undefined,
        detail: cropHarvestBonus,
        onPurchase: function () {
          cropHarvestBonus += 1;
          this.price += 1000 * this.level * 2;
          this.seedPrice *= 2;
          this.detail = cropHarvestBonus;

          if (this.level == this.maxLevel) {
            this.detail = null;
            this.title = `+${cropHarvestBonus} Crop Harvest`;
          }
        }
      },
      {
        id: "sunlamp",
        title: "Install Sunlamp",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 500000,
        seedPrice: 5000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          sunlampUnlocked = true;
          cropGrowthChance *= 2;
        }
      },
      {
        id: "unlock rain",
        title: "Unlock Rain",
        unlocked: false,
        level: 0,
        maxLevel: 1,
        price: 500000,
        seedPrice: 5000,
        x: undefined,
        y: undefined,
        detail: null,
        onPurchase: function () {
          rainUnlocked = true;
        }
      },
      {
        id: "rabbit",
        title: "+1 Rabbit",
        unlocked: false,
        level: 0,
        maxLevel: 3,
        price: 5000,
        seedPrice: 250,
        x: undefined,
        y: undefined,
        detail: cropHarvestBonus,
        onPurchase: function () {
          const signX = Math.sign(Math.random() - .5) || 1;
          const signY = Math.sign(Math.random() - .5) || 1;

          gardenParticles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            xVelocity: signX * rabbitSpeed,
            yVelocity: signY * rabbitSpeed,
            friction: 0,
            lifespan: Infinity,
            color: "white",
            stroke: "gray",
            isCollector: true,
            size: 16,
          });
          this.price *= 5;
          this.seedPrice *= 3;

          if (this.level == this.maxLevel) {
            this.title = `${this.level} Rabbits`;
          }
        }
      },
    ];

    //#region collisions
    const doCollisions = (collider, mode) => {
      if (mode == "main") {
        for (let i = 0; i < targets.length; i++) {
          const target = targets[i];
          if (rectsDoCollide(collider, target)) collectTarget(target);
        }

        for (let i = 0; i < specialTargets.length; i++) {
          const target = specialTargets[i];
          if (rectsDoCollide(collider, target)) collectSpecialTarget(target);
        }
      } else if (mode == "shop") {
        shopFocus = undefined;
        for (let i = 0; i < shopItems.length; i++) {
          const item = shopItems[i];
          if (purchaseIsValid(item) && rectsDoCollide(collider, { ...item, size: shopButtonSize })) {
            shopFocus = item;
            break;
          }
        }
      } else if (mode == "garden") {
        for (let i = 0; i < gardenPlots.length; i++) {
          const plot = gardenPlots[i];

          for (let j = 0; j < plot.strips.length; j++) {
            const strip = plot.strips[j];

            for (let k = 0; k < strip.length; k++) {
              const crop = strip[k];

              if (crop.growth >= 1 && rectsDoCollide(collider, { x: crop.x, y: crop.y, size: maxCropSize })) harvestCrop(crop);
            }
          }
        }
        for (let i = 0; i < gardenTargets.length; i++) {
          const target = gardenTargets[i];
          
          if (rectsDoCollide(collider, target)) collectGardenTarget(target);
        }
      } else if (mode == "farmers market") {
        shopFocus = undefined;
        for (let i = 0; i < farmersMarketItems.length; i++) {
          const item = farmersMarketItems[i];
          const purchaseIsValid = item.price <= points && (item.seedPrice ? item.seedPrice <= seeds : true) && item.level < item.maxLevel;
          if (purchaseIsValid && rectsDoCollide(collider, { ...item, size: shopButtonSize })) {
            shopFocus = item;
            break;
          }
        }
      }
    }

    const rectsDoCollide = (rect1, rect2) => {
      const r1Half = rect1.size / 2;
      const r1 = {
        top: rect1.y - r1Half,
        bottom: +rect1.y + r1Half,
        right: +rect1.x + r1Half,
        left: rect1.x - r1Half,
      }

      const r2Half = rect2.size / 2;
      const r2 = {
        top: rect2.y - r2Half,
        bottom: +rect2.y + r2Half,
        right: +rect2.x + r2Half,
        left: rect2.x - r2Half,
      }

      const xCollision = r1.left < r2.right && r1.left > r2.left || r1.right > r2.left && r1.right < r2.right;
      const yCollision = r1.top < r2.bottom && r1.top > r2.top || r1.bottom > r2.top && r1.bottom < r2.bottom;

      return xCollision && yCollision;
    }
    //#endregion

    //#region player
    const setupPlayerControls = () => {
      window.addEventListener("keydown", (event) => {
        keys[event.key.toLowerCase()] = true;
      });

      window.addEventListener("keyup", (event) => {
        keys[event.key.toLowerCase()] = false;
      });
    }

    const drawPlayer = () => {
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x - (player.size / 2), player.y - (player.size / 2), player.size, player.size);
    }

    const movePlayer = deltaT => {
      let xSign = Math.sign(player.xVelocity);
      let ySign = Math.sign(player.yVelocity);

      const left = keys["a"] || keys["arrowleft"];
      const right = keys["d"] || keys["arrowright"];
      const up = keys["w"] || keys["arrowup"];
      const down = keys["s"] || keys["arrowdown"];

      // x momentum
      if (left || right) {
        if (left) player.xVelocity = Math.max(player.xVelocity - player.acceleration, -player.maxVelocity);
        if (right) player.xVelocity = Math.min(player.xVelocity + player.acceleration, player.maxVelocity);

        xSign = Math.sign(player.xVelocity);
      } else {
        if (xSign) player.xVelocity -= player.friction * xSign;
      }

      // y momentum 
      if (up || down) {
        if (up) player.yVelocity = Math.max(player.yVelocity - player.acceleration, -player.maxVelocity);
        if (down) player.yVelocity = Math.min(player.yVelocity + player.acceleration, player.maxVelocity);

        ySign = Math.sign(player.yVelocity);
      } else {
        if (ySign) player.yVelocity -= player.friction * ySign;
      }

      // move
      player.x += player.xVelocity;
      player.y += player.yVelocity;

      // keep the player on screen
      const primaryScenes = Object.keys(sceneDoors);
      const secondaryScenes = Object.values(sceneDoors);
      const sceneIsPrimary = secondaryScenes.indexOf(scene) < 0;
      if (player.x > canvas.width) {
        if (primaryScenes.length > 1) {
          const rightScene = sceneIsPrimary ? primaryScenes[(primaryScenes.indexOf(scene) + 1) % primaryScenes.length] : secondaryScenes[(secondaryScenes.indexOf(scene) + 1) % secondaryScenes.length];
          if (player.y < canvas.height / 2 + doorSize && player.y > canvas.height / 2 - doorSize) {
            scene = rightScene;
            player.x = 20;
          }
        }

        player.xVelocity -= player.acceleration * 2;
      }
      if (player.x < 0) {
        if (primaryScenes.length > 1) {
          const leftScene = sceneIsPrimary ? primaryScenes[Math.abs(primaryScenes.indexOf(scene) - 1) % primaryScenes.length] : secondaryScenes[Math.abs(secondaryScenes.indexOf(scene) - 1) % secondaryScenes.length];
          if (player.y < canvas.height / 2 + doorSize && player.y > canvas.height / 2 - doorSize) {
            scene = leftScene;
            player.x = canvas.width - 20;
          }
        }

        player.xVelocity += player.acceleration * 2;
      }
      if (player.y > canvas.height) {
        const lowerScene = sceneDoors[scene];
        if (player.x < canvas.width / 2 + doorSize && player.x > canvas.width / 2 - doorSize && lowerScene) {
          scene = lowerScene;
          player.y = 20;
        }

        player.yVelocity -= player.acceleration * 2;
      }
      if (player.y < 0) {
        const upperScene = primaryScenes.find(key => sceneDoors[key] === scene);
        if (player.x < canvas.width / 2 + doorSize && player.x > canvas.width / 2 - doorSize && upperScene) {
          scene = upperScene;
          player.y = canvas.height - 20;
        }

        player.yVelocity += player.acceleration * 2;
      }
    }
    //#endregion

    //#region particles
    const moveParticles = () => {
      for (let i = 0; i < particles.length; i++) {
        const particle = particles[i];

        // keep the particle on screen
        if (particle.x > canvas.width) particle.xVelocity -= 2;
        if (particle.y > canvas.height) particle.yVelocity -= 2;
        if (particle.x < 0) particle.xVelocity += 2;
        if (particle.y < 0) particle.yVelocity += 2;

        if (particle.xVelocity || particle.yVelocity) {
          // move
          particle.x += particle.xVelocity;
          particle.y += particle.yVelocity;

          // slow down
          const xSign = Math.sign(particle.xVelocity);
          const ySign = Math.sign(particle.yVelocity);
          if (xSign) particle.xVelocity -= particle.friction * xSign;
          if (ySign) particle.yVelocity -= particle.friction * ySign;
        }

        if (particle.isCollector) doCollisions({ x: particle.x, y: particle.y, size: particleSize }, "main");

        // die off
        if (--particle.lifespan < 1) {
          if (particle.onDeath) particle.onDeath();
          particles.splice(i, 1);
        }
      }

      for (let i = 0; i < shopParticles.length; i++) {
        const particle = shopParticles[i];

        if (particle.xVelocity || particle.yVelocity) {
          // move
          particle.x += particle.xVelocity;
          particle.y += particle.yVelocity;

          // slow down
          const xSign = Math.sign(particle.xVelocity);
          const ySign = Math.sign(particle.yVelocity);
          if (xSign) particle.xVelocity -= particle.friction * xSign;
          if (ySign) particle.yVelocity -= particle.friction * ySign;
        }

        // die off
        if (--particle.lifespan < 1) {
          if (particle.onDeath) particle.onDeath();
          shopParticles.splice(i, 1);
        }
      }

      for (let i = 0; i < gardenParticles.length; i++) {
        const particle = gardenParticles[i];

        if (scene != "garden" && particle.isCosmetic) continue;

        // keep the particle on screen
        if (!particle.ignoreWalls) {
          if (particle.x > canvas.width) particle.xVelocity = -Math.abs(particle.xVelocity);
          if (particle.y > canvas.height) particle.yVelocity = -Math.abs(particle.yVelocity);
          if (particle.x < 0) particle.xVelocity = Math.abs(particle.yVelocity);
          if (particle.y < 0) particle.yVelocity = Math.abs(particle.yVelocity);
        }
        
        if (particle.xVelocity || particle.yVelocity) {
          // move
          particle.x += particle.xVelocity;
          particle.y += particle.yVelocity;

          // slow down
          const xSign = Math.sign(particle.xVelocity);
          const ySign = Math.sign(particle.yVelocity);
          if (xSign) particle.xVelocity -= particle.friction * xSign;
          if (ySign) particle.yVelocity -= particle.friction * ySign;
        }

        if (particle.isCollector) doCollisions({ x: particle.x, y: particle.y, size: particle.size ? particle.size : particleSize }, "garden");

        // die off
        if (--particle.lifespan < 1) {
          if (particle.onDeath) particle.onDeath();
          gardenParticles.splice(i, 1);
        }
      }
    }

    const drawParticles = () => {
      let particleArray = particles;
      if (scene == "shop" || scene == "farmers market") {
        particleArray = shopParticles;
      } else if (scene == "garden") {
        particleArray = gardenParticles;
      }

      for (let i = 0; i < particleArray.length; i++) {
        const particle = particleArray[i];
        ctx.fillStyle = particle.color;
        ctx.fillRect(particle.x - particleSize / 2, particle.y - particleSize / 2, particle.size ? particle.size : particleSize, particle.size ? particle.size : particleSize);

        if (particle.stroke) {
          ctx.lineWidth = particle.strokeSize || 1;
          ctx.strokeStyle = particle.stroke;
          ctx.strokeRect(particle.x - particleSize / 2, particle.y - particleSize / 2, particle.size ? particle.size : particleSize, particle.size ? particle.size : particleSize);
        }
      }
    }
    //#endregion

    //#region targets
    const spawnTarget = (x, y) => {
      const superPotent = Math.random() < superPotentChance;
      const potency = superPotent ? superPotentValue : Math.random() * maxNormalPotency;
      const breadth = Math.random();

      const newTarget = {
        x: x ? x : Math.trunc(Math.random() * canvas.width),
        y: y ? y : Math.trunc(Math.random() * canvas.height),
        size: Math.trunc(breadth * breadthSizeBonus + minimumTargetSize),
        color: randoColor(Math.max(potency, .1)),
        confetti: Math.trunc(potency * potencyBonus / 2 + breadth * breadthBonus / 2),
      };

      if (superPotent) newTarget.stroke = "#ccc";

      targets.push(newTarget);
    }

    const spawnSpecialTarget = type => {
      if (type == "dark") {
        const breadth = Math.random();

        const newTarget = {
          x: Math.trunc(Math.random() * canvas.width),
          y: Math.trunc(Math.random() * canvas.height),
          size: Math.trunc(breadth * 40 + 40),
          color: "black",
          stroke: "white",
          strokeSize: 2,
          confetti: Math.trunc(breadth * breadthBonus + 20 * darkTargetConfettiMult),
          type: type,
        };

        specialTargets.push(newTarget);
      } else if (type == "explosive") {
        const newTarget = {
          x: Math.trunc(Math.random() * canvas.width),
          y: Math.trunc(Math.random() * canvas.height),
          size: 16,
          color: "red",
          stroke: "maroon",
          strokeSize: 3,
          confetti: minExplosiveConfetti,
          type: type,
        };

        specialTargets.push(newTarget);
      } else if (type == "gold") {
        const newTarget = {
          x: Math.trunc(Math.random() * canvas.width),
          y: Math.trunc(Math.random() * canvas.height),
          size: Math.random() * goldTargetSize / 2 + goldTargetSize,
          color: "gold",
          stroke: "#E0B600",
          strokeSize: 3, 
          confetti: 0,
          type: type,
        };

        specialTargets.push(newTarget);
      } else if (type == "rain") {
        const newTarget = {
          x: Math.trunc(Math.random() * canvas.width),
          y: Math.trunc(Math.random() * canvas.height),
          size: 18,
          color: "#6495ED84",
          confetti: 50,
          type: type,
        };

        gardenTargets.push(newTarget);
      }
    }

    const drawTargets = targetArray => {
      for (let i = 0; i < targetArray.length; i++) {
        const target = targetArray[i];

        if (target.stroke) {
          ctx.strokeStyle = target.stroke;
          ctx.lineWidth = target.strokeSize || 1;
          ctx.strokeRect(target.x - (target.size / 2), target.y - (target.size / 2), target.size, target.size);
        }

        ctx.fillStyle = target.color;
        ctx.fillRect(target.x - (target.size / 2), target.y - (target.size / 2), target.size, target.size);
      }
    }

    const collectTarget = target => {
      const drops = target.confetti + particleBase;
      for (let i = 0; i < drops; i++) {
        particles.push({
          x: target.x,
          y: target.y,
          xVelocity: Math.trunc(Math.random() * (drops / 3 + 16) - (drops / 6 + 8)),
          yVelocity: Math.trunc(Math.random() * (drops / 3 + 16) - (drops / 6 + 8)),
          friction: 1,
          lifespan: Math.trunc((normalParticleTime + Math.random() * normalParticleTime / 2) * FPS),
          color: target.color,
          onDeath: () => { points += 1 * pointsMult },
        });
      }

      targets.splice(targets.indexOf(target), 1);
    }

    const collectSpecialTarget = target => {
      if (target.type == "dark") {
        const maxVelo = 25 + darkTargetConfettiMult * 2;
        for (let i = 0; i < target.confetti; i++) {
          // spawn particles that become new generic targets
          particles.push({
            x: target.x,
            y: target.y,
            xVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
            yVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
            friction: 1,
            lifespan: Math.trunc((2 + Math.random()) / 2 * FPS),
            color: target.color,
            onDeath: function () { spawnTarget(this.x, this.y) },
          });
        }
      } else if (target.type == "explosive") {
        // spawn many high velocity particles
        for (let i = 0; i < target.confetti * explosiveConfettiMult; i++) {
          particles.push({
            x: target.x,
            y: target.y,
            xVelocity: Math.trunc(Math.random() * 140 - 70),
            yVelocity: Math.trunc(Math.random() * 140 - 70),
            friction: 0,
            lifespan: Math.trunc((.4 + Math.random() * .4) * FPS * explosiveLifetimeMult),
            color: "orange",
            isCollector: true,
            onDeath: () => { points += 1 * pointsMult },
          });
        }
      } else if (target.type == "gold") {
        // spawn high value particles on contact
        target.size -= goldTargetDecay;

        if (goldAutoCollect) {
          autoCollectTargets.push(target);
          specialTargets.splice(specialTargets.indexOf(target), 1);
        }

        const maxVelo = 25 + 4 * goldTargetDrop;
        for (let i = 0; i < goldTargetDrop; i++) {
          particles.push({
            x: target.x,
            y: target.y,
            xVelocity: Math.trunc(Math.random() * maxVelo - maxVelo / 2),
            yVelocity: Math.trunc(Math.random() * maxVelo - maxVelo / 2),
            friction: 1,
            lifespan: Math.trunc((normalParticleTime + Math.random() * normalParticleTime / 2) * FPS),
            color: target.color,
            onDeath: () => {
              points += 5 * pointsMult;
            },
          });
        }

        if (target.size < goldTargetMinSize) specialTargets.splice(specialTargets.indexOf(target), 1);
      }
      
      if (target.type == "gold") return;
      specialTargets.splice(specialTargets.indexOf(target), 1);
    }

    const collectGardenTarget = target => {
      if (target.type == "rain") {
        // start rain
        if (!rainDuration) {
          rainIntensity = Math.random() * .5 + .5;
          rainSpeed = Math.random() * 10 + 20 * rainIntensity;
          rainAngle = Math.random() * 4 - 2;
          rainAmount = Math.ceil(Math.random() * 5 * rainIntensity);
        }
        rainDuration = 3600;

        // water plots
        for (let i = 0; i < gardenPlots.length; i++) {
          const plot = gardenPlots[i];
          plot.isWet = true;
          plot.wetLifespan = Math.trunc(Math.random() * wetRandRange + minWetLifespan);
        }
        farmersMarketItems.find(e=>e.id == "water plot").refresh();

        // begin target-collection splash effect 
        for (let i = 0; i < target.confetti; i++) {
          gardenParticles.push({
            x: target.x,
            y: target.y,
            xVelocity: Math.trunc(Math.random() * 40 - 20),
            yVelocity: Math.trunc(Math.random() * 40 - 20),
            friction: 1,
            lifespan: Math.trunc((.1 + Math.random() / 4) * FPS),
            color: target.color,
            isCosmetic: true,
          });
        }
      }
      gardenTargets.splice(gardenTargets.indexOf(target), 1);
    }

    const doAutoCollection = () => {
      for (let i = 0; i < autoCollectTargets.length; i++) {
        const target = autoCollectTargets[i];
        
        if (target.type == "gold") {
          target.size -= goldTargetDecay;
          
          const maxVelo = 25 + 4 * goldTargetDrop;
          for (let i = 0; i < goldTargetDrop; i++) {
            particles.push({
              x: target.x,
              y: target.y,
              xVelocity: Math.trunc(Math.random() * maxVelo - maxVelo / 2),
              yVelocity: Math.trunc(Math.random() * maxVelo - maxVelo / 2),
              friction: 1,
              lifespan: Math.trunc((normalParticleTime + Math.random() * normalParticleTime / 2) * FPS),
              color: target.color,
              onDeath: () => {
                points += 5 * pointsMult;
              },
            });
          }

          if (target.size < goldTargetMinSize) autoCollectTargets.splice(autoCollectTargets.indexOf(target), 1);
        }
      }
    }

    //#region utility functions
    const randoColor = strength => {
      const h = Math.floor(Math.random() * 256);
      const s = Math.trunc(strength * 100);
      const l = 50;
      const a = Math.max(strength.toFixed(2), .3);
      return `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    //#endregion

    const drawCurrencies = startHeight => {
      ctx.textAlign = "center";
      if (gardenIsUnlocked) {
        startHeight -= 20
        ctx.strokeText(`Seeds: ${seeds}`, canvas.width / 2, startHeight + 20);
        ctx.fillText(`Seeds: ${seeds}`, canvas.width / 2, startHeight + 20);
      }

      ctx.strokeText(`Points: ${points}`, canvas.width / 2, startHeight);
      ctx.fillText(`Points: ${points}`, canvas.width / 2, startHeight);
    }

    const drawText = () => {
      // general styles
      ctx.fillStyle = "black";
      ctx.lineWidth = 3;
      ctx.strokeStyle = "white";
      ctx.font = "18px serif";

      // draw version code
      ctx.textAlign = "left";
      ctx.fillText(version, 10, 20);

      // draw currencies
      const sceneIsPrimary = Object.keys(sceneDoors).includes(scene);
      ctx.textAlign = "center";
      if (sceneIsPrimary) {
        drawCurrencies(45);
      } else {
        drawCurrencies(canvas.height - 20);
      }
    }
    
    const drawDoors = () => {
      ctx.lineWidth = 3;
      ctx.strokeStyle = "white";
      ctx.font = "18px serif";

      const primaryScenes = Object.keys(sceneDoors);
      const secondaryScenes = Object.values(sceneDoors);
      const sceneIsPrimary = secondaryScenes.indexOf(scene) < 0;
      const rightScene = sceneIsPrimary ? primaryScenes[(primaryScenes.indexOf(scene) + 1) % primaryScenes.length] : secondaryScenes[(secondaryScenes.indexOf(scene) + 1) % secondaryScenes.length];
      const leftScene = sceneIsPrimary ? primaryScenes[Math.abs(primaryScenes.indexOf(scene) - 1) % primaryScenes.length] : secondaryScenes[Math.abs(secondaryScenes.indexOf(scene) - 1) % secondaryScenes.length];

      const halfHeight = canvas.height / 2;
      const halfWidth = canvas.width / 2;
      if (primaryScenes.length > 1) {
        // draw right label
        ctx.textAlign = "right";
        ctx.fillStyle = "black";
        ctx.strokeText(`${rightScene} ðŸ¡†`, canvas.width - 20, halfHeight);
        ctx.fillText(`${rightScene} ðŸ¡†`, canvas.width - 20, halfHeight);
        ctx.fillStyle = "#aaaa";
        ctx.fillRect(canvas.width - 5, halfHeight - doorSize, 5, doorSize * 2);

        // draw left label
        ctx.textAlign = "left";
        ctx.fillStyle = "black";
        ctx.strokeText(`ðŸ¡„ ${leftScene}`, 20, halfHeight);
        ctx.fillText(`ðŸ¡„ ${leftScene}`, 20, halfHeight);
        ctx.fillStyle = "#aaaa";
        ctx.fillRect(5, halfHeight - doorSize, -5, doorSize * 2);
      }

      const upperScene = primaryScenes.find(key => sceneDoors[key] === scene);
      ctx.textAlign = "center";
      if (sceneDoors[scene]) { // draw bottom label
        ctx.fillStyle = "black";
        ctx.strokeText("ðŸ¡‡", halfWidth, canvas.height - 15);
        ctx.fillText("ðŸ¡‡", halfWidth, canvas.height - 15);
        ctx.strokeText(sceneDoors[scene], halfWidth, canvas.height - 35);
        ctx.fillText(sceneDoors[scene], halfWidth, canvas.height - 35);
        ctx.fillStyle = "#aaa5";
        ctx.fillRect(halfWidth - doorSize, canvas.height, doorSize * 2, -5);
      } else if (upperScene) { // draw top label
        ctx.fillStyle = "black";
        ctx.strokeText("ðŸ¡…", halfWidth, 20);
        ctx.fillText("ðŸ¡…", halfWidth, 20);
        ctx.strokeText(upperScene, halfWidth, 35);
        ctx.fillText(upperScene, halfWidth, 35);
        ctx.fillStyle = "#aaa5";
        ctx.fillRect(halfWidth - doorSize, 5, doorSize * 2, -5);
      }
    }

    const randomEvents = () => {
      // normal targets
      if (Math.random() < targetChance && targets.length < maxTargets) spawnTarget();

      // special targets
      if (darkTargetUnlocked && Math.random() < darkTargetChance * specialTargetRateMult && specialTargets.length < maxSpecialTargets) spawnSpecialTarget("dark");
      if (explosiveTargetUnlocked && Math.random() < explosiveTargetChance * specialTargetRateMult && specialTargets.length < maxSpecialTargets) spawnSpecialTarget("explosive");
      if (goldTargetUnlocked && Math.random() < goldTargetChance * specialTargetRateMult && specialTargets.length < maxSpecialTargets) spawnSpecialTarget("gold");

      // garden targets
      if (rainUnlocked && Math.random() < rainTargetChance && gardenTargets.length < maxGardenTargets) spawnSpecialTarget("rain");
    }

    const spawnRain = () => {
      for (let i = 0; i < rainAmount; i++) {
        gardenParticles.push({
          x: Math.random() * (canvas.width + 60) - 30,
          y: 0,
          xVelocity: rainAngle,
          yVelocity: rainSpeed,
          friction: 0,
          lifespan: (Math.random() * (canvas.height * 1.25 / rainSpeed / 60)) * FPS,
          color: "#6495ED84",
          ignoreWalls: true,
          isCosmetic: true,
        });
      }
      
      rainDuration -= 1;
    }
    
    const update = () => {
      movePlayer();
      moveParticles();
      randomEvents();
      
      growCrops();
      if (!rainDuration) {
        updateGardenWetness();
      } else if (scene == "garden") {
        spawnRain();
      }

      doCollisions(player, scene);

      if (shopFocus) detectPurchase();

      doAutoCollection();
    }

    const render = () => {
      if (scene == "garden" || scene == "farmers market") canvas.style.backgroundColor = "rgb(200, 255, 200)";
      else if (scene == "shop") canvas.style.backgroundColor = "rgb(240, 225, 200)";
      else canvas.style.backgroundColor = "white";
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (Object.values(sceneDoors).includes(scene)) {
        let currentShopArray;
        if (scene == "shop") {
          currentShopArray = shopItems;
        } else if (scene == "farmers market") {
          currentShopArray = farmersMarketItems;
        }

        updateShopPositions(currentShopArray);
        drawShopItems(currentShopArray);
      } else if (Object.keys(sceneDoors).includes(scene)) {
        if (scene == "main") {
          drawTargets(targets);
          drawTargets(specialTargets);
          drawTargets(autoCollectTargets);
        } else if (scene == "garden") {
          drawGardenPlots();
          drawTargets(gardenTargets);
        }
      }

      drawParticles();
      drawText();
      drawDoors();
      drawPlayer();

      if (shopFocus) {
        drawPurchaseButton();
      }
    }

    //#region garden
    let gardenPlots = [];

    const harvestCrop = crop => {
      for (let i = 0; i < crop.confetti + cropHarvestBonus; i++) {
        gardenParticles.push({
          x: crop.x,
          y: crop.y,
          xVelocity: Math.trunc(Math.random() * 14 - 7),
          yVelocity: Math.trunc(Math.random() * 14 - 7),
          friction: 1,
          lifespan: Math.trunc((1 + Math.random() * .5) * FPS),
          color: `hsl(120, 80%, 40%)`,
          onDeath: () => seeds += 1,
        });
      }

      crop.growth = null;
    }

    const growCrops = () => {
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];

        for (let j = 0; j < plot.strips.length; j++) {
          const strip = plot.strips[j];

          for (let k = 0; k < strip.length; k++) {
            const crop = strip[k];

            if (crop.growth < 1 && Math.random() < cropGrowthChance) crop.growth = Math.min(crop.growth + .1 + (plot.isFertile ? .1 : 0) + (plot.isWet ? .1 : 0), 1);
          }
        }
      }
    }

    const updateGardenWetness = () => {
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];
        
        plot.wetLifespan -= 1;
        if (plot.wetLifespan < 1) {
          plot.isWet = false;
          farmersMarketItems.find(e=>e.id == "water plot").refresh();
        }
      }
    }

    const drawGardenPlots = () => {
      const gardenPadding = 100;
      const plotLength = 250;
      const plotHeight = 200;

      const plotsPerGridRow = Math.min(gardenPlots.length, Math.floor((canvas.width - gardenPadding * 2) / plotLength));
      const gridRows = Math.ceil(gardenPlots.length / plotsPerGridRow);
      const plotGapX = (canvas.width - gardenPadding * 2 - plotsPerGridRow * plotLength) / Math.max(1, plotsPerGridRow - 1);
      const plotGapY = (canvas.height - gardenPadding * 2 - gridRows * plotHeight) / Math.max(1, gridRows - 1);

      const stripsPerPlot = 5;
      const plotPadding = 10;
      const stripLength = plotLength - plotPadding * 2;
      const stripHeight = (plotHeight - plotPadding * 2 - plotPadding * (stripsPerPlot - 1)) / stripsPerPlot;

      const cropsPerStrip = 5;
      const cropGap = stripLength / (cropsPerStrip + 1);

      // draw plot
      for (let i = 0; i < gardenPlots.length; i++) {
        const plot = gardenPlots[i];
        const plotColor = `hsl(36, 39%, ${60 - (plot.isFertile ? 15 : 0) - (plot.isWet ? 15 : 0)}%)`;
        const gardenGridX = i % plotsPerGridRow;
        const gardenGridY = Math.floor(i / plotsPerGridRow);

        plot.x = gardenPadding + plotLength * gardenGridX + plotGapX * gardenGridX;
        plot.y = gardenPadding + plotHeight * gardenGridY + plotGapY * gardenGridY;

        ctx.fillStyle = plotColor;
        ctx.fillRect(plot.x, plot.y, plotLength, plotHeight);

        // draw strips
        for (let j = 0; j < plot.strips.length; j++) {
          const strip = plot.strips[j];

          const stripColor = `hsl(36, 39%, ${50 - (plot.isFertile ? 15 : 0) - (plot.isWet ? 15 : 0)}%)`;

          const stripX = plot.x + plotPadding;
          const stripY = plot.y + plotPadding + j * stripHeight + j * plotPadding;

          ctx.fillStyle = stripColor;
          ctx.fillRect(stripX, stripY, stripLength, stripHeight);

          // draw crops
          for (let k = 0; k < strip.length; k++) {
            const crop = strip[k];

            crop.x = stripX + cropGap * (k + 1);
            crop.y = stripY + stripHeight / 2;
            const cropColor = crop.growth == 1 ? "hsl(120, 100%, 33%)" : `hsl(120, ${(crop.growth * .75 + .25) * 100}%, ${(1 - (crop.growth * .4 + .2)) * 100}%)`;
            const sizeMod = crop.growth * .8 + .2;

            ctx.fillStyle = cropColor;
            ctx.fillRect(crop.x - maxCropSize * sizeMod / 2, crop.y - maxCropSize * sizeMod / 2, maxCropSize * sizeMod, maxCropSize * sizeMod);
          }
        }
      }
    }

    //#endregion

    //#region shop
    const purchaseIsValid = shopItem => {
      return (shopItem.price ? shopItem.price <= points : true) && (shopItem.seedPrice ? shopItem.seedPrice <= seeds : true) && (shopItem.maxLevel ? shopItem.level < shopItem.maxLevel : true);
    }

    const detectPurchase = () => {
      if (keys["e"]) {
        shopFocus.level += 1;
        points -= shopFocus.price;
        if (shopFocus.seedPrice) seeds -= shopFocus.seedPrice;
        shopFocus.onPurchase();

        const maxVelo = 2 * shopFocus.level + 10;
        for (let i = 0; i < Math.min(7 * shopFocus.level, 100); i++) {
          shopParticles.push({
            x: shopFocus.x,
            y: shopFocus.y,
            xVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
            yVelocity: Math.trunc(Math.random() * maxVelo * 2 - maxVelo),
            friction: 1,
            lifespan: Math.trunc((.25 + Math.random() * .25) * FPS),
            color: shopFocus.level == shopFocus.maxLevel ? "gold" : "rgb(0, 200, 0)",
          });
        }
        keys["e"] = false;
      }
    }

    const drawPurchaseButton = () => {
      ctx.font = "40px sans-serif";
      ctx.textAlign = "center";
      if (ctx.fillStyle != "lime") ctx.fillStyle = "lime";
      if (ctx.lineWidth != 3) ctx.lineWidth = 3;
      if (ctx.strokeStyle != "black") ctx.strokeStyle = "black";
      ctx.strokeText("E", player.x, player.y - 50);
      ctx.fillText("E", player.x, player.y - 50);
    }

    const updateShopPositions = itemArray => {
      const unlockedItems = itemArray.filter(e => e.unlocked);
      const shopItemsPerRow = 5;
      const shopRows = 4;
      const shopPadding = 3 * shopButtonSize;
      const rowGap = (canvas.height - shopPadding * 2 - shopRows * shopButtonSize) / shopRows;
      const colGap = (canvas.width - shopPadding * 2 - shopItemsPerRow * shopButtonSize) / (shopItemsPerRow - 1);

      for (let i = 0; i < unlockedItems.length; i++) {
        const item = unlockedItems[i];
        if (!item.unlocked) continue;

        const row = Math.floor(i / shopItemsPerRow) + 1;
        const col = i % shopItemsPerRow + 1;

        item.x = shopPadding + (col - 1) * shopButtonSize + (col - 1) * colGap + 20;
        item.y = shopPadding + (row - 1) * shopButtonSize + (row - 1) * rowGap;
      }
    }

    const drawShopItems = itemArray => {
      const unlockedItems = itemArray.filter(e => e.unlocked);

      for (let i = 0; i < unlockedItems.length; i++) {
        const item = unlockedItems[i]

        // draw button
        if (item.level === item.maxLevel) {
          ctx.fillStyle = "gold";
        } else if (item.price <= points && (item.seedPrice ? item.seedPrice <= seeds : true)) {
          ctx.fillStyle = "rgb(0, 200, 0)";
        } else {
          ctx.fillStyle = "rgb(200, 0, 0)";
        }
        ctx.fillRect(item.x - shopButtonSize / 2, item.y - shopButtonSize / 2, shopButtonSize, shopButtonSize);

        // draw "new!" badge
        if (item.level == 0 && !item.purchasedBefore) {
          ctx.font = "bold 20px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = purchaseIsValid(item) ? "rgb(200, 0, 0)" : "rgb(200, 0, 0)";
          ctx.fillText("new!", item.x, item.y - shopButtonSize / 1.5);
        }

        // draw item title
        ctx.font = "20px serif";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        const titleText = item.detail ? `${item.title} : ${item.detail}`: item.title;
        ctx.fillText(titleText, item.x, item.y + shopButtonSize);

        if (!(item.level < item.maxLevel)) continue;

        // draw pricing
        const tempStrings = [];
        if (item.price) tempStrings.push(`${item.price} points`);
        if (item.seedPrice) tempStrings.push(`${item.seedPrice} seeds`);
        if (item.maxLevel && item.maxLevel > 1) tempStrings.push(`${item.level}/${item.maxLevel}`);
        ctx.fillText(tempStrings.join(" : "), item.x, item.y + shopButtonSize + 20);
      }
    }
    //#endregion

    const gameLoop = () => {
      const now = Date.now();
      const deltaT = (now - lastFrameTime) / 1000; // seconds
      lastFrameTime = now;

      update();
      render();
      setTimeout(gameLoop, 1000 / FPS);
    }

    let lastFrameTime = Date.now();

    // start the game with a few targets
    for (let i = 0; i < 5; i++) spawnTarget();

    setupPlayerControls();
    gameLoop();


    function scaleCanvas() {
      const scale = {
        x: window.innerWidth / canvas.width,
        y: window.innerHeight / canvas.height
      }

      var stretchHeightFirst = scale.x > scale.y;

      // Apply scaling
      if (stretchHeightFirst) {
        canvas.style.transformOrigin = 'top';
        canvas.style.transform = 'scale(' + scale.y + ')';
      } else {
        canvas.style.transformOrigin = 'top';
        canvas.style.transform = 'scale(' + scale.x + ')';
      }
    }
    window.addEventListener('resize', scaleCanvas);    
    scaleCanvas();

  </script>
</body>
</html>
